2025-02-16T01:04:35.380+05:30  WARN 27372 --- [order-service] [nio-8766-exec-5] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.lang.Integer` from Object value (token `JsonToken.START_OBJECT`)]



{
  "orderId": 1001,
  "userId": 1,
  "totalAmount": 250.00,
  "orderStatus": "PLACED",
  "deliveryAddressId": 10,
  "deliveryDate": "2024-06-20",
  "orderItems": [
    {
      "orderItemId": 5001,
      "productId": 101,
      "productName": "Laptop",
      "quantity": 1,
      "price": 250.00,
      "discount": 10.0,
      "createdAt": "2024-06-13T10:15:30.000Z",
      "image": "https://example.com/images/laptop.jpg"
    }
  ]
}


package com.genckart.service;

import com.genckart.dto.*;
import com.genckart.entity.Order;
import com.genckart.entity.OrderItem;
import com.genckart.repository.OrderRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.client.CartClient;
import com.genckart.client.UserClient;
import com.genckart.client.ProductClient;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final CartClient cartClient;
    private final UserClient userClient;
    private final ProductClient productClient;

    public OrderServiceImpl(OrderRepository orderRepository, OrderItemRepository orderItemRepository, CartClient cartClient, UserClient userClient, ProductClient productClient) {
        this.orderRepository = orderRepository;
        this.orderItemRepository = orderItemRepository;
        this.cartClient = cartClient;
        this.userClient = userClient;
        this.productClient = productClient;
    }

    @Override
    public OrderDTO placeOrderFromCart(int userId) {
        // Fetch cart details from Cart microservice using OpenFeign
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody() || cartResponse.getBody() == null || cartResponse.getBody().isEmpty()) {
            throw new RuntimeException("Cart is empty or not found for user: " + userId);
        }
        List<CartDTO> cartList = cartResponse.getBody();

        // Flatten cart items from multiple carts
        List<CartItemDTO> cartItems = new ArrayList<>();
        for (CartDTO cart : cartList) {
            cartItems.addAll(cart.getCartItems());
        }

        // Fetch user address from User microservice using OpenFeign
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody() || userResponse.getBody() == null) {
            throw new RuntimeException("User not found: " + userId);
        }
        UserDTO user = userResponse.getBody();
        int addressId = user.getAddressId();

        // Calculate total amount
        double totalAmount = cartItems.stream()
                .mapToDouble(item -> item.getProductPrice() * item.getQuantity())
                .sum();

        // Create order entity
        final Order savedOrder = orderRepository.save(new Order(null, userId, totalAmount, "PLACED", addressId, LocalDate.now().plusDays(7), null, null));

        // Save order items and fetch product details (including discount and image)
        List<OrderItemDTO> orderItemDTOs = cartItems.stream().map(cartItem -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            if (!productResponse.hasBody() || productResponse.getBody() == null) {
                throw new RuntimeException("Product not found: " + cartItem.getProductId());
            }
            ProductDTO product = productResponse.getBody();
            
            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(savedOrder);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItemRepository.save(orderItem);
            
            return new OrderItemDTO(orderItem.getOrderItemId(), cartItem.getProductId(), product.getName(), cartItem.getQuantity(), product.getNewPrice(), product.getDiscount(), product.getImage());
        }).collect(Collectors.toList());

        // Convert to DTO and return
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(userId);
        orderDTO.setTotalAmount(totalAmount);
        orderDTO.setOrderStatus("PLACED");
        orderDTO.setDeliveryAddressId(addressId);
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return orderDTO;
    }

    @Override
    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Implementation to handle placing an order from product details
        throw new UnsupportedOperationException("Method not implemented yet");
    }
}






package com.genckart.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderId;

    @Column(nullable = false)
    private Integer userId;

    @Column(nullable = false)
    private Double totalAmount;

    @Column(nullable = false)
    private String orderStatus;

    @Column(nullable = false)
    private Integer deliveryAddressId;

    @Column(nullable = false)
    private LocalDate deliveryDate;  // Added field for delivery date

    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<OrderItem> orderItems;
}
package com.genckart.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_history")
public class OrderHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderHistoryId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer userId;

    @Column(nullable = false)
    private String orderStatus;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import java.sql.Timestamp;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.data.annotation.CreatedDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_items")
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderItemId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer productId;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import java.sql.Timestamp;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.data.annotation.CreatedDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_items")
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderItemId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer productId;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.validation.constraints.*;
import lombok.*;

import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
@ToString
public class UserDTO {
    @NotNull(message = "Name cannot be null")
    @Size(min = 2, max = 100, message = "Name must be between 2 and 100 characters")
    private String name;

    @NotNull(message = "Email cannot be null")
    @Email(message = "Email should be valid")
    private String email;

    @NotNull(message = "Phone number cannot be null")
    @Pattern(regexp = "^\\+?[0-9. ()-]{7,25}$", message = "Phone number is invalid")
    private String phoneNumber;

    @NotNull(message = "Role cannot be null")
    private String role;

    @Min(value = 1, message = "Address ID must be greater than or equal to 1")
    private int addressId;

    @JsonIgnore
    private List<AddressDTO> addresses;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderItemDTO {
    private Integer orderItemId;
    private Integer productId;
    private String productName;
    private Integer quantity;
    private Double price;
    private Double discount;
    @JsonIgnore
    private Timestamp createdAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderHistoryDTO {
    private Integer orderHistoryId;
    private Integer orderId;
    private Integer userId;
    private String orderStatus;
    @JsonIgnore
    private Timestamp statusChangedAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderDTO {
    @JsonIgnore
    private Integer orderId;
    private Integer userId;
    private Double totalAmount;
    private String orderStatus;
    private Integer deliveryAddressId;
    private LocalDate deliveryDate;
    @JsonIgnore
    private Timestamp createdAt;

    private List<OrderItemDTO> orderItems; // List of order items

    private List<OrderHistoryDTO> orderHistory; // List of order history
}
package com.genckart.dto;

import lombok.Data;

@Data
public class CartItemDTO {

    private Integer cartItemId;
    private Integer userId;
    private Integer productId;
    private Integer quantity;
    private String productName;
    private Double productPrice;
}
package com.genckart.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class CartDTO {

    private Integer cartId;
    private int userId;
    private int productId;
    private int quantity;
    private LocalDateTime addedAt;
    private String userName;
    private List<CartItemDTO> cartItems;
}
package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class AddressDTO {
    private int addressId;
    private String street;
    private String city;
    private String state;
    private String postalCode;
    private String country;
}
