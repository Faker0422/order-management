
@Transactional
public OrderDTO placeOrderFromProductDetailPage(@RequestBody OrderDTO orderDTO) {
    Integer userId = orderDTO.getUserId();

    // Fetch user details (including address)
    ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
    if (!userResponse.getStatusCode().is2xxSuccessful() || userResponse.getBody() == null) {
        throw new RuntimeException("Failed to fetch user details.");
    }

    UserDTO user = userResponse.getBody();
    Integer deliveryAddressId = user.getAddressId(); // Extract addressId from UserDTO

    double totalAmount = 0.0;
    List<OrderItem> orderItems = new ArrayList<>();

    // Process each order item
    for (OrderItemDTO itemDTO : orderDTO.getOrderItems()) {
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(itemDTO.getProductId());
        if (!productResponse.getStatusCode().is2xxSuccessful() || productResponse.getBody() == null) {
            throw new RuntimeException("Failed to fetch product details for productId: " + itemDTO.getProductId());
        }

        ProductDTO product = productResponse.getBody();

        // ✅ Set total price directly to newPrice (ignoring discount and quantity)
        double totalPrice = product.getNewPrice();

        // Create OrderItem entity
        OrderItem orderItem = new OrderItem();
        orderItem.setProductId(product.getProductId());
        orderItem.setQuantity(itemDTO.getQuantity()); // Storing quantity
        orderItem.setOrder(order); // Associate with order

        orderItems.add(orderItem);
        totalAmount += totalPrice; // ✅ Add newPrice to total order amount
    }

    // Create and save Order entity
    Order order = new Order();
    order.setUserId(userId);
    order.setTotalAmount(totalAmount);
    order.setOrderStatus("PLACED");
    order.setDeliveryAddressId(deliveryAddressId);
    order.setDeliveryDate(LocalDate.now().plusDays(7));
    order = orderRepository.save(order);

    // Associate and save order items
    for (OrderItem item : orderItems) {
        item.setOrder(order);
    }
    orderItemRepository.saveAll(orderItems);

    // Convert and return DTO (including order and order items)
    return convertToDTO(order);
}


















@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderHistoryRepository orderHistoryRepository;
    private final UserClient userClient;
    private final ProductClient productClient;

    @Transactional
    public OrderDTO placeOrderFromProductDetailPage(@RequestBody OrderDTO orderDTO) {
        Integer userId = orderDTO.getUserId();

        // Fetch user address
        ResponseEntity<AddressDTO> addressResponse = userClient.getUserAddress(userId);
        if (!addressResponse.getStatusCode().is2xxSuccessful() || addressResponse.getBody() == null) {
            throw new RuntimeException("Failed to fetch user address.");
        }
        Integer deliveryAddressId = addressResponse.getBody().getAddressId();

        double totalAmount = 0.0;
        List<OrderItem> orderItems = new ArrayList<>();

        // Process each order item
        for (OrderItemDTO itemDTO : orderDTO.getOrderItems()) {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(itemDTO.getProductId());
            if (!productResponse.getStatusCode().is2xxSuccessful() || productResponse.getBody() == null) {
                throw new RuntimeException("Failed to fetch product details for productId: " + itemDTO.getProductId());
            }

            ProductDTO product = productResponse.getBody();
            double effectivePrice = product.getNewPrice() - (product.getDiscount() != null ? product.getDiscount() : 0);
            double itemTotal = effectivePrice * itemDTO.getQuantity();
            totalAmount += itemTotal;

            // Create OrderItem entity
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(product.getProductId());
            orderItem.setQuantity(itemDTO.getQuantity());
            orderItems.add(orderItem);
        }

        // Create and save Order entity
        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(totalAmount);
        order.setOrderStatus("PLACED");
        order.setDeliveryAddressId(deliveryAddressId);
        order.setDeliveryDate(LocalDate.now().plusDays(7));
        order = orderRepository.save(order);

        // Associate and save order items
        for (OrderItem item : orderItems) {
            item.setOrder(order);
        }
        orderItemRepository.saveAll(orderItems);

        // Create OrderHistory entry
        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(order);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PLACED");
        orderHistoryRepository.save(orderHistory);

        // Convert and return DTO
        return convertToDTO(order);
    }
}
















public OrderDTO placeOrderFromCart(Integer userId) {
        // Fetch the cart details for the user
        ResponseEntity<CartResponse> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody() || cartResponse.getBody().getCartItems() == null || cartResponse.getBody().getCartItems().isEmpty()) {
            throw new IllegalStateException("Cart is empty or unavailable for user: " + userId);
        }
        List<CartItem> cartItems = cartResponse.getBody().getCartItems();

        // Fetch the user's delivery address
        ResponseEntity<AddressDTO> addressResponse = userClient.getUserAddress(userId);
        if (!addressResponse.hasBody()) {
            throw new IllegalStateException("Delivery address not found for user: " + userId);
        }
        AddressDTO deliveryAddress = addressResponse.getBody();

        // Create and save the order
        Order order = new Order();
        order.setUserId(userId);
        order.setDeliveryAddressId(deliveryAddress.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));
        order.setOrderStatus("CREATED");
        order.setCreatedAt(LocalDateTime.now());

        order = orderRepository.save(order); // Save order to get generated ID

        // Process each cart item into an OrderItem
        List<OrderItem> orderItems = new ArrayList<>();
        double totalAmount = 0.0;

        for (CartItem cartItem : cartItems) {
            // Fetch product details
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            if (!productResponse.hasBody()) {
                throw new IllegalStateException("Product details not found for productId: " + cartItem.getProductId());
            }
            ProductDTO product = productResponse.getBody();

            // Extract product details
            double price = product.getNewPrice();
            double discount = product.getDiscount();
            String productName = product.getName();

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(order);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItem.setPrice(price);
            orderItem.setDiscount(discount);
            orderItem.setProductName(productName);

            orderItems.add(orderItem);
            totalAmount += price * cartItem.getQuantity();
        }

        // Save order items and update total amount
        orderItemRepository.saveAll(orderItems);
        order.setTotalAmount(totalAmount);
        orderRepository.save(order);

        // Convert order to DTO and return it
        return convertToDTO(order);
    }
















private OrderDTO convertToDTO(Order order) {
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getOrderId());
        orderDTO.setUserId(order.getUserId());
        orderDTO.setTotalAmount(order.getTotalAmount());
        orderDTO.setOrderStatus(order.getOrderStatus());
        orderDTO.setDeliveryAddressId(order.getDeliveryAddressId());
        orderDTO.setDeliveryDate(order.getDeliveryDate());
        orderDTO.setCreatedAt(order.getCreatedAt());

        orderDTO.setOrderItems(orderItemRepository.findByOrderId(order.getOrderId())
                .stream().map(this::convertToOrderItemDTO).collect(Collectors.toList()));

        orderDTO.setOrderHistory(orderHistoryRepository.findByOrderId(order.getOrderId())
                .stream().map(this::convertToOrderHistoryDTO).collect(Collectors.toList()));

        return orderDTO;
    }

    private OrderItemDTO convertToOrderItemDTO(OrderItem orderItem) {
        OrderItemDTO orderItemDTO = new OrderItemDTO();
        orderItemDTO.setOrderItemId(orderItem.getOrderItemId());
        orderItemDTO.setProductId(orderItem.getProductId());
        orderItemDTO.setQuantity(orderItem.getQuantity());

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(orderItem.getProductId());
        if (productResponse.hasBody()) {
            ProductDTO product = productResponse.getBody();
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTO.setPrice(product.getNewPrice());
        } else {
            orderItemDTO.setProductName("Unknown Product");
            orderItemDTO.setPrice(0.0);
            orderItemDTO.setDiscount(0.0);
        }
        return orderItemDTO;
    }

    private OrderHistoryDTO convertToOrderHistoryDTO(OrderHistory orderHistory) {
        OrderHistoryDTO orderHistoryDTO = new OrderHistoryDTO();
        orderHistoryDTO.setOrderHistoryId(orderHistory.getOrderHistoryId());
        orderHistoryDTO.setOrderId(orderHistory.getOrder().getOrderId());
        orderHistoryDTO.setUserId(orderHistory.getUserId());
        orderHistoryDTO.setOrderStatus(orderHistory.getOrderStatus());
        return orderHistoryDTO;
    }
}







@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final CartServiceFeignClient cartServiceFeignClient;
    private final UserServiceFeignClient userServiceFeignClient;
    private final ProductServiceFeignClient productServiceFeignClient;

    @Transactional
    public ResponseEntity<OrderDTO> placeOrderFromCart(Integer userId) {
        // Fetch user details
        UserDTO user = fetchUserDetails(userId);
        if (user == null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }

        // Fetch cart items
        List<CartItemDTO> cartItems = fetchCartItems(userId);
        if (cartItems == null || cartItems.isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }

        // Process order items & calculate total amount
        List<OrderItem> orderItems = new ArrayList<>();
        List<OrderItemDTO> orderItemDTOs = new ArrayList<>();
        double totalAmount = processOrderItems(cartItems, orderItems, orderItemDTOs);

        // Save order
        Order savedOrder = saveOrder(user, totalAmount, orderItems);

        // Build response DTO
        OrderDTO orderDTO = buildOrderDTO(savedOrder, orderItemDTOs);

        return ResponseEntity.ok(orderDTO);
    }

    private UserDTO fetchUserDetails(Integer userId) {
        ResponseEntity<UserDTO> userResponse = userServiceFeignClient.getUserById(userId);
        return (userResponse.getStatusCode() == HttpStatus.OK) ? userResponse.getBody() : null;
    }

    private List<CartItemDTO> fetchCartItems(Integer userId) {
        ResponseEntity<CartDTO> cartResponse = cartServiceFeignClient.getCartByUserId(userId);
        return (cartResponse.getStatusCode() == HttpStatus.OK && cartResponse.getBody() != null)
                ? cartResponse.getBody().getCartItems()
                : null;
    }

    private double processOrderItems(List<CartItemDTO> cartItems, List<OrderItem> orderItems, List<OrderItemDTO> orderItemDTOs) {
        double totalAmount = 0.0;

        for (CartItemDTO cartItem : cartItems) {
            ProductDTO product = fetchProductDetails(cartItem.getProductId());
            if (product == null) continue;

            // Calculate price after discount
            double itemPrice = product.getNewPrice() - (product.getNewPrice() * (product.getDiscount() / 100));
            double itemTotal = itemPrice * cartItem.getQuantity();
            totalAmount += itemTotal;

            // Create OrderItem entity
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(product.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItems.add(orderItem);

            // Create OrderItemDTO
            OrderItemDTO orderItemDTO = new OrderItemDTO();
            orderItemDTO.setProductId(product.getProductId());
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setQuantity(cartItem.getQuantity());
            orderItemDTO.setPrice(product.getNewPrice());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTOs.add(orderItemDTO);
        }

        return totalAmount;
    }

    private ProductDTO fetchProductDetails(Integer productId) {
        ResponseEntity<ProductDTO> productResponse = productServiceFeignClient.getProductById(productId);
        return (productResponse.getStatusCode() == HttpStatus.OK) ? productResponse.getBody() : null;
    }

    private Order saveOrder(UserDTO user, double totalAmount, List<OrderItem> orderItems) {
        Order order = new Order();
        order.setUserId(user.getAddressId());
        order.setTotalAmount(totalAmount);
        order.setOrderStatus("PLACED");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));
        order.setOrderItems(orderItems);

        Order savedOrder = orderRepository.save(order);
        orderItems.forEach(item -> item.setOrder(savedOrder));
        orderItemRepository.saveAll(orderItems);
        return savedOrder;
    }

    private OrderDTO buildOrderDTO(Order savedOrder, List<OrderItemDTO> orderItemDTOs) {
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(savedOrder.getUserId());
        orderDTO.setTotalAmount(savedOrder.getTotalAmount());
        orderDTO.setOrderStatus(savedOrder.getOrderStatus());
        orderDTO.setDeliveryAddressId(savedOrder.getDeliveryAddressId());
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);
        return orderDTO;
    }
}























public OrderDTO placeOrderFromCart(Integer userId) {
        // Fetch cart details from Cart microservice using OpenFeign
        ResponseEntity<CartDTO> cartResponse = cartClient.getCartByUserId(userId);

        CartDTO cartList = cartResponse.getBody();

        // Flatten cart items from multiple carts
        List<CartItemDTO> cartItems = new ArrayList<>();

        // Fetch user address from User microservice using OpenFeign
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody() || userResponse.getBody() == null) {
            throw new RuntimeException("User not found: " + userId);
        }
        UserDTO user = userResponse.getBody();
        int addressId = user.getAddressId();

        // Calculate total amount
        double totalAmount = cartItems.stream()
                .mapToDouble(item -> item.getProductPrice() * item.getQuantity())
                .sum();

        // Create order entity
        final Order savedOrder = orderRepository.save(new Order(null, userId, totalAmount, "PLACED", addressId, LocalDate.now().plusDays(7), null, null));

        // Save order items and fetch product details (including discount and image)
        List<OrderItemDTO> orderItemDTOs = cartItems.stream().map(cartItem -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            if (!productResponse.hasBody() || productResponse.getBody() == null) {
                throw new RuntimeException("Product not found: " + cartItem.getProductId());
            }
            ProductDTO product = productResponse.getBody();

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(savedOrder);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItemRepository.save(orderItem);

            return new OrderItemDTO(orderItem.getOrderItemId(), cartItem.getProductId(), product.getName(), cartItem.getQuantity(), product.getNewPrice(), product.getDiscount(), product.getImage(),new Timestamp(System.currentTimeMillis()));
        }).collect(Collectors.toList());

        // Convert to DTO and return
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(userId);
        orderDTO.setTotalAmount(totalAmount);
        orderDTO.setOrderStatus("PLACED");
        orderDTO.setDeliveryAddressId(addressId);
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return orderDTO;
    }

{
    "userId": 2,
    "totalAmount": 0.0,
    "orderStatus": "PLACED",
    "deliveryAddressId": 0,
    "deliveryDate": "2025-02-23",
    "orderItems": [],
    "orderHistory": null
}




@Override
    public OrderDTO placeOrderFromCart(Integer userId) {
        // Fetch cart details from Cart microservice
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody() || cartResponse.getBody() == null || cartResponse.getBody().isEmpty()) {
            throw new RuntimeException("Cart is empty or not found for user: " + userId);
        }
        List<CartDTO> cartList = cartResponse.getBody();

        // Flatten cart items from multiple carts
        List<CartItemDTO> cartItems = new ArrayList<>();
        for (CartDTO cart : cartList) {
            cartItems.addAll(cart.getCartItems());
        }

        // Fetch user address from User microservice
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody() || userResponse.getBody() == null) {
            throw new RuntimeException("User not found: " + userId);
        }
        UserDTO user = userResponse.getBody();
        int addressId = user.getAddressId();

        // Calculate total amount considering discounts
        double totalAmount = cartItems.stream().mapToDouble(item -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(item.getProductId());
            if (!productResponse.hasBody() || productResponse.getBody() == null) {
                throw new RuntimeException("Product not found: " + item.getProductId());
            }
            ProductDTO product = productResponse.getBody();
            double discountedPrice = product.getNewPrice() - (product.getNewPrice() * (product.getDiscount() / 100));
            return discountedPrice * item.getQuantity();
        }).sum();

        // Save order
        Order savedOrder = orderRepository.save(new Order(null, userId, totalAmount, "PLACED", addressId, LocalDate.now().plusDays(7), null, null));

        // Save order items
        List<OrderItemDTO> orderItemDTOs = cartItems.stream().map(cartItem -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            ProductDTO product = productResponse.getBody();

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(savedOrder);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItemRepository.save(orderItem);

            return new OrderItemDTO(orderItem.getOrderItemId(), cartItem.getProductId(), product.getName(), cartItem.getQuantity(), product.getNewPrice(), product.getDiscount(), null, product.getImage());
        }).collect(Collectors.toList());

        // Convert to DTO and return response
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(userId);
        orderDTO.setTotalAmount(totalAmount);
        orderDTO.setOrderStatus("PLACED");
        orderDTO.setDeliveryAddressId(addressId);
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return orderDTO;
    }


{
  "orderId": 1001,
  "userId": 1,
  "totalAmount": 250.00,
  "orderStatus": "PLACED",
  "deliveryAddressId": 10,
  "deliveryDate": "2024-06-20",
  "orderItems": [
    {
      "orderItemId": 5001,
      "productId": 101,
      "productName": "Laptop",
      "quantity": 1,
      "price": 250.00,
      "discount": 10.0,
      "createdAt": "2024-06-13T10:15:30.000Z",
      "image": "https://example.com/images/laptop.jpg"
    }
  ]
}


package com.genckart.service;

import com.genckart.dto.*;
import com.genckart.entity.Order;
import com.genckart.entity.OrderItem;
import com.genckart.repository.OrderRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.client.CartClient;
import com.genckart.client.UserClient;
import com.genckart.client.ProductClient;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final CartClient cartClient;
    private final UserClient userClient;
    private final ProductClient productClient;

    public OrderServiceImpl(OrderRepository orderRepository, OrderItemRepository orderItemRepository, CartClient cartClient, UserClient userClient, ProductClient productClient) {
        this.orderRepository = orderRepository;
        this.orderItemRepository = orderItemRepository;
        this.cartClient = cartClient;
        this.userClient = userClient;
        this.productClient = productClient;
    }

    @Override
    public OrderDTO placeOrderFromCart(int userId) {
        // Fetch cart details from Cart microservice using OpenFeign
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody() || cartResponse.getBody() == null || cartResponse.getBody().isEmpty()) {
            throw new RuntimeException("Cart is empty or not found for user: " + userId);
        }
        List<CartDTO> cartList = cartResponse.getBody();

        // Flatten cart items from multiple carts
        List<CartItemDTO> cartItems = new ArrayList<>();
        for (CartDTO cart : cartList) {
            cartItems.addAll(cart.getCartItems());
        }

        // Fetch user address from User microservice using OpenFeign
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody() || userResponse.getBody() == null) {
            throw new RuntimeException("User not found: " + userId);
        }
        UserDTO user = userResponse.getBody();
        int addressId = user.getAddressId();

        // Calculate total amount
        double totalAmount = cartItems.stream()
                .mapToDouble(item -> item.getProductPrice() * item.getQuantity())
                .sum();

        // Create order entity
        final Order savedOrder = orderRepository.save(new Order(null, userId, totalAmount, "PLACED", addressId, LocalDate.now().plusDays(7), null, null));

        // Save order items and fetch product details (including discount and image)
        List<OrderItemDTO> orderItemDTOs = cartItems.stream().map(cartItem -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            if (!productResponse.hasBody() || productResponse.getBody() == null) {
                throw new RuntimeException("Product not found: " + cartItem.getProductId());
            }
            ProductDTO product = productResponse.getBody();
            
            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(savedOrder);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItemRepository.save(orderItem);
            
            return new OrderItemDTO(orderItem.getOrderItemId(), cartItem.getProductId(), product.getName(), cartItem.getQuantity(), product.getNewPrice(), product.getDiscount(), product.getImage());
        }).collect(Collectors.toList());

        // Convert to DTO and return
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(userId);
        orderDTO.setTotalAmount(totalAmount);
        orderDTO.setOrderStatus("PLACED");
        orderDTO.setDeliveryAddressId(addressId);
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return orderDTO;
    }

    @Override
    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Implementation to handle placing an order from product details
        throw new UnsupportedOperationException("Method not implemented yet");
    }
}






package com.genckart.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderId;

    @Column(nullable = false)
    private Integer userId;

    @Column(nullable = false)
    private Double totalAmount;

    @Column(nullable = false)
    private String orderStatus;

    @Column(nullable = false)
    private Integer deliveryAddressId;

    @Column(nullable = false)
    private LocalDate deliveryDate;  // Added field for delivery date

    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<OrderItem> orderItems;
}
package com.genckart.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_history")
public class OrderHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderHistoryId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer userId;

    @Column(nullable = false)
    private String orderStatus;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import java.sql.Timestamp;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.data.annotation.CreatedDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_items")
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderItemId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer productId;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import java.sql.Timestamp;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.data.annotation.CreatedDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_items")
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderItemId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer productId;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.validation.constraints.*;
import lombok.*;

import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
@ToString
public class UserDTO {
    @NotNull(message = "Name cannot be null")
    @Size(min = 2, max = 100, message = "Name must be between 2 and 100 characters")
    private String name;

    @NotNull(message = "Email cannot be null")
    @Email(message = "Email should be valid")
    private String email;

    @NotNull(message = "Phone number cannot be null")
    @Pattern(regexp = "^\\+?[0-9. ()-]{7,25}$", message = "Phone number is invalid")
    private String phoneNumber;

    @NotNull(message = "Role cannot be null")
    private String role;

    @Min(value = 1, message = "Address ID must be greater than or equal to 1")
    private int addressId;

    @JsonIgnore
    private List<AddressDTO> addresses;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderItemDTO {
    private Integer orderItemId;
    private Integer productId;
    private String productName;
    private Integer quantity;
    private Double price;
    private Double discount;
    @JsonIgnore
    private Timestamp createdAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderHistoryDTO {
    private Integer orderHistoryId;
    private Integer orderId;
    private Integer userId;
    private String orderStatus;
    @JsonIgnore
    private Timestamp statusChangedAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderDTO {
    @JsonIgnore
    private Integer orderId;
    private Integer userId;
    private Double totalAmount;
    private String orderStatus;
    private Integer deliveryAddressId;
    private LocalDate deliveryDate;
    @JsonIgnore
    private Timestamp createdAt;

    private List<OrderItemDTO> orderItems; // List of order items

    private List<OrderHistoryDTO> orderHistory; // List of order history
}
package com.genckart.dto;

import lombok.Data;

@Data
public class CartItemDTO {

    private Integer cartItemId;
    private Integer userId;
    private Integer productId;
    private Integer quantity;
    private String productName;
    private Double productPrice;
}
package com.genckart.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class CartDTO {

    private Integer cartId;
    private int userId;
    private int productId;
    private int quantity;
    private LocalDateTime addedAt;
    private String userName;
    private List<CartItemDTO> cartItems;
}
package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class AddressDTO {
    private int addressId;
    private String street;
    private String city;
    private String state;
    private String postalCode;
    private String country;
}


package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProductDTO {
    private Integer productId;
    private String name;
    private double newPrice;
    private Double discount;
    private String image;
    private String description;
}

