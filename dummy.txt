
@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final CartServiceFeignClient cartServiceFeignClient;
    private final UserServiceFeignClient userServiceFeignClient;
    private final ProductServiceFeignClient productServiceFeignClient;

    @Transactional
    public ResponseEntity<OrderDTO> placeOrderFromCart(@RequestBody Integer userId) {
        // Fetch user details including address
        ResponseEntity<UserDTO> userResponse = userServiceFeignClient.getUserById(userId);
        if (userResponse.getStatusCode() != HttpStatus.OK || userResponse.getBody() == null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
        UserDTO user = userResponse.getBody();

        // Fetch cart details
        ResponseEntity<CartDTO> cartResponse = cartServiceFeignClient.getCartByUserId(userId);
        if (cartResponse.getStatusCode() != HttpStatus.OK || cartResponse.getBody() == null) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }
        CartDTO cart = cartResponse.getBody();

        List<CartItemDTO> cartItems = cart.getCartItems();
        if (cartItems.isEmpty()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
        }

        // Calculate total amount
        double totalAmount = 0.0;
        List<OrderItem> orderItems = new ArrayList<>();
        List<OrderItemDTO> orderItemDTOs = new ArrayList<>();

        for (CartItemDTO cartItem : cartItems) {
            ResponseEntity<ProductDTO> productResponse = productServiceFeignClient.getProductById(cartItem.getProductId());
            if (productResponse.getStatusCode() != HttpStatus.OK || productResponse.getBody() == null) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
            }
            ProductDTO product = productResponse.getBody();

            double itemPrice = product.getNewPrice() - (product.getNewPrice() * (product.getDiscount() / 100));
            double itemTotal = itemPrice * cartItem.getQuantity();
            totalAmount += itemTotal;

            // Create order item
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(product.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItems.add(orderItem);

            // Create OrderItemDTO with product details
            OrderItemDTO orderItemDTO = new OrderItemDTO();
            orderItemDTO.setProductId(product.getProductId());
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setQuantity(cartItem.getQuantity());
            orderItemDTO.setPrice(product.getNewPrice());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTO.setImage(product.getImage());

            orderItemDTOs.add(orderItemDTO);
        }

        // Create order
        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(totalAmount);
        order.setOrderStatus("PLACED");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));
        order.setOrderItems(orderItems);

        // Save order and order items
        Order savedOrder = orderRepository.save(order);
        orderItems.forEach(item -> item.setOrder(savedOrder));
        orderItemRepository.saveAll(orderItems);

        // Create OrderDTO
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(savedOrder.getUserId());
        orderDTO.setTotalAmount(savedOrder.getTotalAmount());
        orderDTO.setOrderStatus(savedOrder.getOrderStatus());
        orderDTO.setDeliveryAddressId(savedOrder.getDeliveryAddressId());
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return ResponseEntity.ok(orderDTO);
    }
}

























public OrderDTO placeOrderFromCart(Integer userId) {
        // Fetch cart details from Cart microservice using OpenFeign
        ResponseEntity<CartDTO> cartResponse = cartClient.getCartByUserId(userId);

        CartDTO cartList = cartResponse.getBody();

        // Flatten cart items from multiple carts
        List<CartItemDTO> cartItems = new ArrayList<>();

        // Fetch user address from User microservice using OpenFeign
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody() || userResponse.getBody() == null) {
            throw new RuntimeException("User not found: " + userId);
        }
        UserDTO user = userResponse.getBody();
        int addressId = user.getAddressId();

        // Calculate total amount
        double totalAmount = cartItems.stream()
                .mapToDouble(item -> item.getProductPrice() * item.getQuantity())
                .sum();

        // Create order entity
        final Order savedOrder = orderRepository.save(new Order(null, userId, totalAmount, "PLACED", addressId, LocalDate.now().plusDays(7), null, null));

        // Save order items and fetch product details (including discount and image)
        List<OrderItemDTO> orderItemDTOs = cartItems.stream().map(cartItem -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            if (!productResponse.hasBody() || productResponse.getBody() == null) {
                throw new RuntimeException("Product not found: " + cartItem.getProductId());
            }
            ProductDTO product = productResponse.getBody();

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(savedOrder);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItemRepository.save(orderItem);

            return new OrderItemDTO(orderItem.getOrderItemId(), cartItem.getProductId(), product.getName(), cartItem.getQuantity(), product.getNewPrice(), product.getDiscount(), product.getImage(),new Timestamp(System.currentTimeMillis()));
        }).collect(Collectors.toList());

        // Convert to DTO and return
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(userId);
        orderDTO.setTotalAmount(totalAmount);
        orderDTO.setOrderStatus("PLACED");
        orderDTO.setDeliveryAddressId(addressId);
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return orderDTO;
    }

{
    "userId": 2,
    "totalAmount": 0.0,
    "orderStatus": "PLACED",
    "deliveryAddressId": 0,
    "deliveryDate": "2025-02-23",
    "orderItems": [],
    "orderHistory": null
}




@Override
    public OrderDTO placeOrderFromCart(Integer userId) {
        // Fetch cart details from Cart microservice
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody() || cartResponse.getBody() == null || cartResponse.getBody().isEmpty()) {
            throw new RuntimeException("Cart is empty or not found for user: " + userId);
        }
        List<CartDTO> cartList = cartResponse.getBody();

        // Flatten cart items from multiple carts
        List<CartItemDTO> cartItems = new ArrayList<>();
        for (CartDTO cart : cartList) {
            cartItems.addAll(cart.getCartItems());
        }

        // Fetch user address from User microservice
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody() || userResponse.getBody() == null) {
            throw new RuntimeException("User not found: " + userId);
        }
        UserDTO user = userResponse.getBody();
        int addressId = user.getAddressId();

        // Calculate total amount considering discounts
        double totalAmount = cartItems.stream().mapToDouble(item -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(item.getProductId());
            if (!productResponse.hasBody() || productResponse.getBody() == null) {
                throw new RuntimeException("Product not found: " + item.getProductId());
            }
            ProductDTO product = productResponse.getBody();
            double discountedPrice = product.getNewPrice() - (product.getNewPrice() * (product.getDiscount() / 100));
            return discountedPrice * item.getQuantity();
        }).sum();

        // Save order
        Order savedOrder = orderRepository.save(new Order(null, userId, totalAmount, "PLACED", addressId, LocalDate.now().plusDays(7), null, null));

        // Save order items
        List<OrderItemDTO> orderItemDTOs = cartItems.stream().map(cartItem -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            ProductDTO product = productResponse.getBody();

            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(savedOrder);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItemRepository.save(orderItem);

            return new OrderItemDTO(orderItem.getOrderItemId(), cartItem.getProductId(), product.getName(), cartItem.getQuantity(), product.getNewPrice(), product.getDiscount(), null, product.getImage());
        }).collect(Collectors.toList());

        // Convert to DTO and return response
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(userId);
        orderDTO.setTotalAmount(totalAmount);
        orderDTO.setOrderStatus("PLACED");
        orderDTO.setDeliveryAddressId(addressId);
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return orderDTO;
    }


{
  "orderId": 1001,
  "userId": 1,
  "totalAmount": 250.00,
  "orderStatus": "PLACED",
  "deliveryAddressId": 10,
  "deliveryDate": "2024-06-20",
  "orderItems": [
    {
      "orderItemId": 5001,
      "productId": 101,
      "productName": "Laptop",
      "quantity": 1,
      "price": 250.00,
      "discount": 10.0,
      "createdAt": "2024-06-13T10:15:30.000Z",
      "image": "https://example.com/images/laptop.jpg"
    }
  ]
}


package com.genckart.service;

import com.genckart.dto.*;
import com.genckart.entity.Order;
import com.genckart.entity.OrderItem;
import com.genckart.repository.OrderRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.client.CartClient;
import com.genckart.client.UserClient;
import com.genckart.client.ProductClient;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final CartClient cartClient;
    private final UserClient userClient;
    private final ProductClient productClient;

    public OrderServiceImpl(OrderRepository orderRepository, OrderItemRepository orderItemRepository, CartClient cartClient, UserClient userClient, ProductClient productClient) {
        this.orderRepository = orderRepository;
        this.orderItemRepository = orderItemRepository;
        this.cartClient = cartClient;
        this.userClient = userClient;
        this.productClient = productClient;
    }

    @Override
    public OrderDTO placeOrderFromCart(int userId) {
        // Fetch cart details from Cart microservice using OpenFeign
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody() || cartResponse.getBody() == null || cartResponse.getBody().isEmpty()) {
            throw new RuntimeException("Cart is empty or not found for user: " + userId);
        }
        List<CartDTO> cartList = cartResponse.getBody();

        // Flatten cart items from multiple carts
        List<CartItemDTO> cartItems = new ArrayList<>();
        for (CartDTO cart : cartList) {
            cartItems.addAll(cart.getCartItems());
        }

        // Fetch user address from User microservice using OpenFeign
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody() || userResponse.getBody() == null) {
            throw new RuntimeException("User not found: " + userId);
        }
        UserDTO user = userResponse.getBody();
        int addressId = user.getAddressId();

        // Calculate total amount
        double totalAmount = cartItems.stream()
                .mapToDouble(item -> item.getProductPrice() * item.getQuantity())
                .sum();

        // Create order entity
        final Order savedOrder = orderRepository.save(new Order(null, userId, totalAmount, "PLACED", addressId, LocalDate.now().plusDays(7), null, null));

        // Save order items and fetch product details (including discount and image)
        List<OrderItemDTO> orderItemDTOs = cartItems.stream().map(cartItem -> {
            ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
            if (!productResponse.hasBody() || productResponse.getBody() == null) {
                throw new RuntimeException("Product not found: " + cartItem.getProductId());
            }
            ProductDTO product = productResponse.getBody();
            
            OrderItem orderItem = new OrderItem();
            orderItem.setOrder(savedOrder);
            orderItem.setProductId(cartItem.getProductId());
            orderItem.setQuantity(cartItem.getQuantity());
            orderItemRepository.save(orderItem);
            
            return new OrderItemDTO(orderItem.getOrderItemId(), cartItem.getProductId(), product.getName(), cartItem.getQuantity(), product.getNewPrice(), product.getDiscount(), product.getImage());
        }).collect(Collectors.toList());

        // Convert to DTO and return
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(savedOrder.getOrderId());
        orderDTO.setUserId(userId);
        orderDTO.setTotalAmount(totalAmount);
        orderDTO.setOrderStatus("PLACED");
        orderDTO.setDeliveryAddressId(addressId);
        orderDTO.setDeliveryDate(savedOrder.getDeliveryDate());
        orderDTO.setOrderItems(orderItemDTOs);

        return orderDTO;
    }

    @Override
    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Implementation to handle placing an order from product details
        throw new UnsupportedOperationException("Method not implemented yet");
    }
}






package com.genckart.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderId;

    @Column(nullable = false)
    private Integer userId;

    @Column(nullable = false)
    private Double totalAmount;

    @Column(nullable = false)
    private String orderStatus;

    @Column(nullable = false)
    private Integer deliveryAddressId;

    @Column(nullable = false)
    private LocalDate deliveryDate;  // Added field for delivery date

    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<OrderItem> orderItems;
}
package com.genckart.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_history")
public class OrderHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderHistoryId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer userId;

    @Column(nullable = false)
    private String orderStatus;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import java.sql.Timestamp;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.data.annotation.CreatedDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_items")
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderItemId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer productId;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import java.sql.Timestamp;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.springframework.data.annotation.CreatedDate;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "order_items")
public class OrderItem {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer orderItemId;

    @ManyToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Column(nullable = false)
    private Integer productId;

    @Column(nullable = false)
    private Integer quantity;

    @JsonIgnore
    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.validation.constraints.*;
import lombok.*;

import java.util.List;

@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
@ToString
public class UserDTO {
    @NotNull(message = "Name cannot be null")
    @Size(min = 2, max = 100, message = "Name must be between 2 and 100 characters")
    private String name;

    @NotNull(message = "Email cannot be null")
    @Email(message = "Email should be valid")
    private String email;

    @NotNull(message = "Phone number cannot be null")
    @Pattern(regexp = "^\\+?[0-9. ()-]{7,25}$", message = "Phone number is invalid")
    private String phoneNumber;

    @NotNull(message = "Role cannot be null")
    private String role;

    @Min(value = 1, message = "Address ID must be greater than or equal to 1")
    private int addressId;

    @JsonIgnore
    private List<AddressDTO> addresses;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderItemDTO {
    private Integer orderItemId;
    private Integer productId;
    private String productName;
    private Integer quantity;
    private Double price;
    private Double discount;
    @JsonIgnore
    private Timestamp createdAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderHistoryDTO {
    private Integer orderHistoryId;
    private Integer orderId;
    private Integer userId;
    private String orderStatus;
    @JsonIgnore
    private Timestamp statusChangedAt;
}
package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.sql.Timestamp;
import java.time.LocalDate;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class OrderDTO {
    @JsonIgnore
    private Integer orderId;
    private Integer userId;
    private Double totalAmount;
    private String orderStatus;
    private Integer deliveryAddressId;
    private LocalDate deliveryDate;
    @JsonIgnore
    private Timestamp createdAt;

    private List<OrderItemDTO> orderItems; // List of order items

    private List<OrderHistoryDTO> orderHistory; // List of order history
}
package com.genckart.dto;

import lombok.Data;

@Data
public class CartItemDTO {

    private Integer cartItemId;
    private Integer userId;
    private Integer productId;
    private Integer quantity;
    private String productName;
    private Double productPrice;
}
package com.genckart.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class CartDTO {

    private Integer cartId;
    private int userId;
    private int productId;
    private int quantity;
    private LocalDateTime addedAt;
    private String userName;
    private List<CartItemDTO> cartItems;
}
package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class AddressDTO {
    private int addressId;
    private String street;
    private String city;
    private String state;
    private String postalCode;
    private String country;
}


package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProductDTO {
    private Integer productId;
    private String name;
    private double newPrice;
    private Double discount;
    private String image;
    private String description;
}

