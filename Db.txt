private OrderItemDTO convertToOrderItemDTO(OrderItem orderItem) {
        OrderItemDTO orderItemDTO = new OrderItemDTO();
        orderItemDTO.setOrderItemId(orderItem.getOrderItemId());
        orderItemDTO.setProductId(orderItem.getProductId());
        orderItemDTO.setQuantity(orderItem.getQuantity());

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(orderItem.getProductId());
        if (productResponse.hasBody()) {
            ProductDTO product = productResponse.getBody();
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTO.setFinalPrice(product.getNewPrice());
        } else {
            orderItemDTO.setProductName("Unknown Product");
            orderItemDTO.setPrice(0.0);
            orderItemDTO.setDiscount(0.0);
            orderItemDTO.setFinalPrice(0.0);
        }
        return orderItemDTO;
    }


package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ProductDTO {
    private Integer productId;
    private String name;
    private double newPrice;
    private Double discount;
    private String image;
    private String description;
}
package com.genckart.service.Impl;

import com.genckart.clients.CartClient;
import com.genckart.clients.ProductClient;
import com.genckart.clients.UserClient;
import com.genckart.dto.*;
import com.genckart.entity.*;
import com.genckart.exception.OrderNotFoundException;
import com.genckart.repository.OrderHistoryRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.repository.OrderRepository;
import com.genckart.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderHistoryRepository orderHistoryRepository;
    private final UserClient userClient;
    private final ProductClient productClient;
    private final CartClient cartClient;

    @Override
    public OrderDTO placeOrderFromCart(Integer userId) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        System.out.println("User Address ID: " + user.getAddressId()); // Debugging

        // Extract CartDTO from ResponseEntity
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody()) {
            throw new OrderNotFoundException("Cart not found for user ID: " + userId);
        }
        List<CartDTO> cartList = cartResponse.getBody();

        if (cartList == null || cartList.isEmpty()) {
            throw new OrderNotFoundException("Cart is empty for user ID: " + userId);
        }

        // Create a new Order
        Order order = new Order();
        order.setUserId(userId);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());  // Ensure user has a valid address
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        AtomicReference<Double> totalAmount = new AtomicReference<>(0.0);

        List<OrderItem> orderItems = cartList.stream()
                .flatMap(cartDTO -> cartDTO.getCartItems().stream())
                .map(cartItem -> {
                    OrderItem orderItem = new OrderItem();
                    orderItem.setOrder(order);
                    orderItem.setProductId(cartItem.getProductId());
                    orderItem.setQuantity(cartItem.getQuantity());

                    // Get product details
                    ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
                    if (productResponse.hasBody()) {
                        ProductDTO product = productResponse.getBody();
                        double productPrice = product.getNewPrice();
                        double discountPercentage = product.getDiscount() != null ? product.getDiscount() : 0.0;
                        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
                        double finalPrice = discountedPrice * cartItem.getQuantity();

                        totalAmount.updateAndGet(v -> v + finalPrice);
                    } else {
                        System.out.println("Product not found for ID: " + cartItem.getProductId());
                    }
                    return orderItem;
                }).collect(Collectors.toList());

        order.setTotalAmount(totalAmount.get());

        Order savedOrder = orderRepository.save(order);
        orderItems.forEach(item -> item.setOrder(savedOrder));
        orderItemRepository.saveAll(orderItems);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        // Fetch order details after saving
        OrderDTO orderDTO = convertToDTO(savedOrder);

        // Set order items in response
        orderDTO.setOrderItems(orderItemRepository.findByOrderId(savedOrder.getOrderId())
                .stream().map(this::convertToOrderItemDTO).collect(Collectors.toList()));

        // Set order history in response
        orderDTO.setOrderHistory(orderHistoryRepository.findByOrderId(savedOrder.getOrderId())
                .stream().map(this::convertToOrderHistoryDTO).collect(Collectors.toList()));

        return orderDTO;
    }

    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(productId);
        if (!productResponse.hasBody()) {
            throw new OrderNotFoundException("Product not found for ID: " + productId);
        }
        ProductDTO product = productResponse.getBody();

        double productPrice = product.getNewPrice();
        double discountPercentage = product.getDiscount();
        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
        double finalPrice = discountedPrice * quantity;

        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(finalPrice);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        Order savedOrder = orderRepository.save(order);

        OrderItem orderItem = new OrderItem();
        orderItem.setOrder(savedOrder);
        orderItem.setProductId(productId);
        orderItem.setQuantity(quantity);
        orderItemRepository.save(orderItem);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO getOrderDetails(Integer orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + orderId));

        List<OrderItem> orderItems = orderItemRepository.findByOrderId(orderId);
        List<OrderHistory> orderHistory = orderHistoryRepository.findByOrderId(orderId);

        OrderDTO orderDTO = convertToDTO(order);
        orderDTO.setOrderItems(orderItems.stream()
                .map(this::convertToOrderItemDTO)
                .collect(Collectors.toList()));
        orderDTO.setOrderHistory(orderHistory.stream()
                .map(this::convertToOrderHistoryDTO)
                .collect(Collectors.toList()));

        return orderDTO;
    }

    public List<OrderDTO> getOrderHistory(Integer userId) {
        List<Order> orders = orderRepository.findByUserId(userId);
        if (orders.isEmpty()) {
            throw new OrderNotFoundException("No orders found for user ID: " + userId);
        }
        return orders.stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Transactional
    public void deleteOrder(Integer orderId) {
        if (!orderRepository.existsById(orderId)) {
            throw new OrderNotFoundException("Order not found with ID: " + orderId);
        }
        orderItemRepository.deleteByOrder_OrderId(orderId);
        orderHistoryRepository.deleteByOrder_OrderId(orderId);
        orderRepository.deleteById(orderId);
    }

    private OrderDTO convertToDTO(Order order) {
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getOrderId());
        orderDTO.setUserId(order.getUserId());
        orderDTO.setTotalAmount(order.getTotalAmount());
        orderDTO.setOrderStatus(order.getOrderStatus());
        orderDTO.setDeliveryAddressId(order.getDeliveryAddressId());
        orderDTO.setDeliveryDate(order.getDeliveryDate());
        orderDTO.setCreatedAt(order.getCreatedAt());
        return orderDTO;
    }

    private OrderItemDTO convertToOrderItemDTO(OrderItem orderItem) {
        OrderItemDTO orderItemDTO = new OrderItemDTO();
        orderItemDTO.setOrderItemId(orderItem.getOrderItemId());
        orderItemDTO.setProductId(orderItem.getProductId());
        orderItemDTO.setQuantity(orderItem.getQuantity());

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(orderItem.getProductId());
        if (productResponse.hasBody()) {
            ProductDTO product = productResponse.getBody();
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTO.setFinalPrice(product.getNewPrice());
        } else {
            orderItemDTO.setProductName("Unknown Product");
            orderItemDTO.setPrice(0.0);
            orderItemDTO.setDiscount(0.0);
            orderItemDTO.setFinalPrice(0.0);
        }
        return orderItemDTO;
    }

    private OrderHistoryDTO convertToOrderHistoryDTO(OrderHistory orderHistory) {
        OrderHistoryDTO orderHistoryDTO = new OrderHistoryDTO();
        orderHistoryDTO.setOrderHistoryId(orderHistory.getOrderHistoryId());
        orderHistoryDTO.setOrderId(orderHistory.getOrder().getOrderId());
        orderHistoryDTO.setUserId(orderHistory.getUserId());
        orderHistoryDTO.setOrderStatus(orderHistory.getOrderStatus());
        return orderHistoryDTO;
    }
}












public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(productId);
        if (!productResponse.hasBody()) {
            throw new OrderNotFoundException("Product not found for ID: " + productId);
        }
        ProductDTO product = productResponse.getBody();

        double productPrice = product.getNewPrice();
        double discountPercentage = product.getDiscount();
        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
        double finalPrice = discountedPrice * quantity;

        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(finalPrice);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        Order savedOrder = orderRepository.save(order);

        OrderItem orderItem = new OrderItem();
        orderItem.setOrder(savedOrder);
        orderItem.setProductId(productId);
        orderItem.setQuantity(quantity);
        orderItemRepository.save(orderItem);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }
2025-02-15T20:12:50.734+05:30 ERROR 32060 --- [Order-Service] [nio-9091-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.lang.NullPointerException: Cannot invoke "java.lang.Double.doubleValue()" because the return value of "com.genckart.dto.ProductDTO.getDiscount()" is null] with root cause

java.lang.NullPointerException: Cannot invoke "java.lang.Double.doubleValue()" because the return value of "com.genckart.dto.ProductDTO.getDiscount()" is null
	at com.genckart.service.Impl.OrderServiceImpl.placeOrderFromProductDetail(OrderServiceImpl.java:132) ~[classes/:na]
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.2.jar:6.2.2]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:723) ~[spring-aop-6.2.2.jar:6.2.2]
	at com.genckart.service.Impl.OrderServiceImpl$$SpringCGLIB$$0.placeOrderFromProductDetail(<generated>) ~[classes/:na]
	at com.genckart.controller.OrderController.placeOrderFromProductDetail(OrderController.java:30) ~[classes/:na]
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:257) ~[spring-web-6.2.2.jar:6.2.2]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:190) ~[spring-web-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:118) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:986) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:891) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1088) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:978) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:590) ~[tomcat-embed-core-10.1.34.jar:6.0]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885) ~[spring-webmvc-6.2.2.jar:6.2.2]
	at jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658) ~[tomcat-embed-core-10.1.34.jar:6.0]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) ~[tomcat-embed-websocket-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-6.2.2.jar:6.2.2]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.2.2.jar:6.2.2]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-6.2.2.jar:6.2.2]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.2.2.jar:6.2.2]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.springframework.web.filter.ServerHttpObservationFilter.doFilterInternal(ServerHttpObservationFilter.java:114) ~[spring-web-6.2.2.jar:6.2.2]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.2.2.jar:6.2.2]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-6.2.2.jar:6.2.2]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116) ~[spring-web-6.2.2.jar:6.2.2]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:397) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1741) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1190) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63) ~[tomcat-embed-core-10.1.34.jar:10.1.34]
	at java.base/java.lang.Thread.run(Thread.java:1570) ~[na:na]

User Address ID: 0
Hibernate: insert into orders (delivery_address_id,delivery_date,order_status,total_amount,user_id) values (?,?,?,?,?)
Hibernate: insert into order_items (order_id,product_id,quantity) values (?,?,?)
Hibernate: insert into order_history (order_id,order_status,user_id) values (?,?,?)
Hibernate: select oi1_0.order_item_id,oi1_0.created_at,oi1_0.order_id,oi1_0.product_id,oi1_0.quantity from order_items oi1_0 where oi1_0.order_id=?
Hibernate: select oh1_0.order_history_id,oh1_0.order_id,oh1_0.order_status,oh1_0.user_id from order_history oh1_0 where oh1_0.order_id=?
2025-02-15T20:15:04.521+05:30  INFO 32060 --- [Order-Service] [rap-executor-%d] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration



















@Override
public OrderDTO placeOrderFromCart(Integer userId) {
    // Extract UserDTO from ResponseEntity
    ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
    if (!userResponse.hasBody()) {
        throw new OrderNotFoundException("User not found for ID: " + userId);
    }
    UserDTO user = userResponse.getBody();

    System.out.println("User Address ID: " + user.getAddressId()); // Debugging

    // Extract CartDTO from ResponseEntity
    ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
    if (!cartResponse.hasBody()) {
        throw new OrderNotFoundException("Cart not found for user ID: " + userId);
    }
    List<CartDTO> cartList = cartResponse.getBody();

    if (cartList == null || cartList.isEmpty()) {
        throw new OrderNotFoundException("Cart is empty for user ID: " + userId);
    }

    // Create a new Order
    Order order = new Order();
    order.setUserId(userId);
    order.setOrderStatus("PENDING");
    order.setDeliveryAddressId(user.getAddressId());  // Ensure user has a valid address
    order.setDeliveryDate(LocalDate.now().plusDays(7));

    AtomicReference<Double> totalAmount = new AtomicReference<>(0.0);

    List<OrderItem> orderItems = cartList.stream()
            .flatMap(cartDTO -> cartDTO.getCartItems().stream())
            .map(cartItem -> {
                OrderItem orderItem = new OrderItem();
                orderItem.setOrder(order);
                orderItem.setProductId(cartItem.getProductId());
                orderItem.setQuantity(cartItem.getQuantity());

                // Get product details
                ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
                if (productResponse.hasBody()) {
                    ProductDTO product = productResponse.getBody();
                    double productPrice = product.getNewPrice();
                    double discountPercentage = product.getDiscount() != null ? product.getDiscount() : 0.0;
                    double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
                    double finalPrice = discountedPrice * cartItem.getQuantity();

                    totalAmount.updateAndGet(v -> v + finalPrice);
                } else {
                    System.out.println("Product not found for ID: " + cartItem.getProductId());
                }
                return orderItem;
            }).collect(Collectors.toList());

    order.setTotalAmount(totalAmount.get());

    Order savedOrder = orderRepository.save(order);
    orderItems.forEach(item -> item.setOrder(savedOrder));
    orderItemRepository.saveAll(orderItems);

    OrderHistory orderHistory = new OrderHistory();
    orderHistory.setOrder(savedOrder);
    orderHistory.setUserId(userId);
    orderHistory.setOrderStatus("PENDING");
    orderHistoryRepository.save(orderHistory);

    // Fetch order details after saving
    OrderDTO orderDTO = convertToDTO(savedOrder);

    // Set order items in response
    orderDTO.setOrderItems(orderItemRepository.findByOrderId(savedOrder.getOrderId())
            .stream().map(this::convertToOrderItemDTO).collect(Collectors.toList()));

    // Set order history in response
    orderDTO.setOrderHistory(orderHistoryRepository.findByOrderId(savedOrder.getOrderId())
            .stream().map(this::convertToOrderHistoryDTO).collect(Collectors.toList()));

    return orderDTO;
}























requestbody:
{
    "orderId": 3,
    "userId": 5,
    "totalAmount": 2700.0,
    "orderStatus": "PENDING",
    "deliveryAddressId": 103,
    "deliveryDate": "2025-02-24",
    "orderItems": [
        {
            "productId": 5,
            "productName": "Product Name 1",
            "quantity": 2,
            "price": 500.0,
            "discount": 10.0,
            "finalPrice": 450.0,
            "createdAt": "2025-02-15T06:54:36.000+00:00"
        },
        {
            "productId": 6,
            "productName": "Product Name 2",
            "quantity": 3,
            "price": 600.0,
            "discount": 15.0,
            "finalPrice": 510.0,
            "createdAt": "2025-02-15T06:54:36.000+00:00"
        }
    ]   
}
response:
{
    "userId": 3,
    "totalAmount": 0.0,
    "orderStatus": "PENDING",
    "deliveryAddressId": 0,
    "deliveryDate": "2025-02-22",
    "orderItems": null,
    "orderHistory": null
}

package com.genckart.service.Impl;

import com.genckart.clients.CartClient;
import com.genckart.clients.ProductClient;
import com.genckart.clients.UserClient;
import com.genckart.dto.*;
import com.genckart.entity.*;
import com.genckart.exception.OrderNotFoundException;
import com.genckart.repository.OrderHistoryRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.repository.OrderRepository;
import com.genckart.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderHistoryRepository orderHistoryRepository;
    private final UserClient userClient;
    private final ProductClient productClient;
    private final CartClient cartClient;

    @Override
    public OrderDTO placeOrderFromCart(Integer userId) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract CartDTO from ResponseEntity
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody()) {
            throw new OrderNotFoundException("Cart not found for user ID: " + userId);
        }
        List<CartDTO> cartList = cartResponse.getBody();

        if (cartList == null || cartList.isEmpty()) {
            throw new OrderNotFoundException("Cart is empty for user ID: " + userId);
        }

        // Create a new Order
        Order order = new Order();
        order.setUserId(userId);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        // Use AtomicReference to store total amount (to avoid lambda variable issue)
        AtomicReference<Double> totalAmount = new AtomicReference<>(0.0);

        List<OrderItem> orderItems = cartList.stream()
                .flatMap(cartDTO -> cartDTO.getCartItems().stream()) // Extract cart items
                .map(cartItem -> {
                    OrderItem orderItem = new OrderItem();
                    orderItem.setOrder(order);
                    orderItem.setProductId(cartItem.getProductId());
                    orderItem.setQuantity(cartItem.getQuantity());

                    // Get product details to calculate price
                    ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
                    if (productResponse.hasBody()) {
                        ProductDTO product = productResponse.getBody();
                        double productPrice = product.getNewPrice();
                        double discountPercentage = product.getDiscount() != null ? product.getDiscount() : 0.0;
                        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
                        double finalPrice = discountedPrice * cartItem.getQuantity();

                        // Update total amount using AtomicReference
                        totalAmount.updateAndGet(v -> v + finalPrice);
                    }
                    return orderItem;
                }).collect(Collectors.toList());

        // Set total amount before saving
        order.setTotalAmount(totalAmount.get());

        Order savedOrder = orderRepository.save(order);
        orderItems.forEach(item -> item.setOrder(savedOrder));
        orderItemRepository.saveAll(orderItems);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(productId);
        if (!productResponse.hasBody()) {
            throw new OrderNotFoundException("Product not found for ID: " + productId);
        }
        ProductDTO product = productResponse.getBody();

        double productPrice = product.getNewPrice();
        double discountPercentage = product.getDiscount();
        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
        double finalPrice = discountedPrice * quantity;

        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(finalPrice);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        Order savedOrder = orderRepository.save(order);

        OrderItem orderItem = new OrderItem();
        orderItem.setOrder(savedOrder);
        orderItem.setProductId(productId);
        orderItem.setQuantity(quantity);
        orderItemRepository.save(orderItem);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO getOrderDetails(Integer orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + orderId));

        List<OrderItem> orderItems = orderItemRepository.findByOrderId(orderId);
        List<OrderHistory> orderHistory = orderHistoryRepository.findByOrderId(orderId);

        OrderDTO orderDTO = convertToDTO(order);
        orderDTO.setOrderItems(orderItems.stream()
                .map(this::convertToOrderItemDTO)
                .collect(Collectors.toList()));
        orderDTO.setOrderHistory(orderHistory.stream()
                .map(this::convertToOrderHistoryDTO)
                .collect(Collectors.toList()));

        return orderDTO;
    }

    public List<OrderDTO> getOrderHistory(Integer userId) {
        List<Order> orders = orderRepository.findByUserId(userId);
        if (orders.isEmpty()) {
            throw new OrderNotFoundException("No orders found for user ID: " + userId);
        }
        return orders.stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Transactional
    public void deleteOrder(Integer orderId) {
        if (!orderRepository.existsById(orderId)) {
            throw new OrderNotFoundException("Order not found with ID: " + orderId);
        }
        orderItemRepository.deleteByOrder_OrderId(orderId);
        orderHistoryRepository.deleteByOrder_OrderId(orderId);
        orderRepository.deleteById(orderId);
    }

    private OrderDTO convertToDTO(Order order) {
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getOrderId());
        orderDTO.setUserId(order.getUserId());
        orderDTO.setTotalAmount(order.getTotalAmount());
        orderDTO.setOrderStatus(order.getOrderStatus());
        orderDTO.setDeliveryAddressId(order.getDeliveryAddressId());
        orderDTO.setDeliveryDate(order.getDeliveryDate());
        orderDTO.setCreatedAt(order.getCreatedAt());
        return orderDTO;
    }

    private OrderItemDTO convertToOrderItemDTO(OrderItem orderItem) {
        OrderItemDTO orderItemDTO = new OrderItemDTO();
        orderItemDTO.setOrderItemId(orderItem.getOrderItemId());
        orderItemDTO.setProductId(orderItem.getProductId());
        orderItemDTO.setQuantity(orderItem.getQuantity());

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(orderItem.getProductId());
        if (productResponse.hasBody()) {
            ProductDTO product = productResponse.getBody();
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setPrice(product.getOldPrice());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTO.setFinalPrice(product.getNewPrice());
        } else {
            orderItemDTO.setProductName("Unknown Product");
            orderItemDTO.setPrice(0.0);
            orderItemDTO.setDiscount(0.0);
            orderItemDTO.setFinalPrice(0.0);
        }
        return orderItemDTO;
    }

    private OrderHistoryDTO convertToOrderHistoryDTO(OrderHistory orderHistory) {
        OrderHistoryDTO orderHistoryDTO = new OrderHistoryDTO();
        orderHistoryDTO.setOrderHistoryId(orderHistory.getOrderHistoryId());
        orderHistoryDTO.setOrderId(orderHistory.getOrder().getOrderId());
        orderHistoryDTO.setUserId(orderHistory.getUserId());
        orderHistoryDTO.setOrderStatus(orderHistory.getOrderStatus());
        return orderHistoryDTO;
    }
}















@Override
public OrderDTO placeOrderFromCart(Integer userId) {
    // Extract UserDTO from ResponseEntity
    ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
    if (!userResponse.hasBody()) {
        throw new OrderNotFoundException("User not found for ID: " + userId);
    }
    UserDTO user = userResponse.getBody();

    // Extract CartDTO from ResponseEntity
    ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
    if (!cartResponse.hasBody()) {
        throw new OrderNotFoundException("Cart not found for user ID: " + userId);
    }
    List<CartDTO> cartList = cartResponse.getBody();

    if (cartList == null || cartList.isEmpty()) {
        throw new OrderNotFoundException("Cart is empty for user ID: " + userId);
    }

    // Create a new Order
    Order order = new Order();
    order.setUserId(userId);
    order.setOrderStatus("PENDING");
    order.setDeliveryAddressId(user.getAddressId());
    order.setDeliveryDate(LocalDate.now().plusDays(7));

    // Use AtomicReference to store total amount (to avoid lambda variable issue)
    AtomicReference<Double> totalAmount = new AtomicReference<>(0.0);

    List<OrderItem> orderItems = cartList.stream()
            .flatMap(cartDTO -> cartDTO.getCartItems().stream()) // Extract cart items
            .map(cartItem -> {
                OrderItem orderItem = new OrderItem();
                orderItem.setOrder(order);
                orderItem.setProductId(cartItem.getProductId());
                orderItem.setQuantity(cartItem.getQuantity());

                // Get product details to calculate price
                ResponseEntity<ProductDTO> productResponse = productClient.getProductById(cartItem.getProductId());
                if (productResponse.hasBody()) {
                    ProductDTO product = productResponse.getBody();
                    double productPrice = product.getNewPrice();
                    double discountPercentage = product.getDiscount();
                    double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
                    double finalPrice = discountedPrice * cartItem.getQuantity();
                    
                    // Update total amount using AtomicReference
                    totalAmount.updateAndGet(v -> v + finalPrice);
                }
                return orderItem;
            }).collect(Collectors.toList());

    // Set total amount before saving
    order.setTotalAmount(totalAmount.get());

    Order savedOrder = orderRepository.save(order);
    orderItems.forEach(item -> item.setOrder(savedOrder));
    orderItemRepository.saveAll(orderItems);

    OrderHistory orderHistory = new OrderHistory();
    orderHistory.setOrder(savedOrder);
    orderHistory.setUserId(userId);
    orderHistory.setOrderStatus("PENDING");
    orderHistoryRepository.save(orderHistory);

    return convertToDTO(savedOrder);
}













package com.genckart.service.Impl;

import com.genckart.clients.CartClient;
import com.genckart.clients.ProductClient;
import com.genckart.clients.UserClient;
import com.genckart.dto.*;
import com.genckart.entity.*;
import com.genckart.exception.OrderNotFoundException;
import com.genckart.repository.OrderHistoryRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.repository.OrderRepository;
import com.genckart.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderHistoryRepository orderHistoryRepository;
    private final UserClient userClient;
    private final ProductClient productClient;
    private final CartClient cartClient;

    @Override
    public OrderDTO placeOrderFromCart(Integer userId) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract CartDTO from ResponseEntity
        ResponseEntity<List<CartDTO>> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody()) {
            throw new OrderNotFoundException("Cart not found for user ID: " + userId);
        }
        List<CartDTO> cart = cartResponse.getBody();

        Order order = new Order();
        order.setUserId(userId);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        List<OrderItem> orderItems = cart.getCartItems().stream()
                .map(item -> {
                    OrderItem orderItem = new OrderItem();
                    orderItem.setOrder(order);
                    orderItem.setProductId(item.getProductId());
                    orderItem.setQuantity(item.getQuantity());
                    return orderItem;
                }).collect(Collectors.toList());

        Order savedOrder = orderRepository.save(order);
        orderItems.forEach(item -> item.setOrder(savedOrder));
        orderItemRepository.saveAll(orderItems);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(productId);
        if (!productResponse.hasBody()) {
            throw new OrderNotFoundException("Product not found for ID: " + productId);
        }
        ProductDTO product = productResponse.getBody();

        double productPrice = product.getNewPrice();
        double discountPercentage = product.getDiscount();
        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
        double finalPrice = discountedPrice * quantity;

        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(finalPrice);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        Order savedOrder = orderRepository.save(order);

        OrderItem orderItem = new OrderItem();
        orderItem.setOrder(savedOrder);
        orderItem.setProductId(productId);
        orderItem.setQuantity(quantity);
        orderItemRepository.save(orderItem);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO getOrderDetails(Integer orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + orderId));

        List<OrderItem> orderItems = orderItemRepository.findByOrderId(orderId);
        List<OrderHistory> orderHistory = orderHistoryRepository.findByOrderId(orderId);

        OrderDTO orderDTO = convertToDTO(order);
        orderDTO.setOrderItems(orderItems.stream()
                .map(this::convertToOrderItemDTO)
                .collect(Collectors.toList()));
        orderDTO.setOrderHistory(orderHistory.stream()
                .map(this::convertToOrderHistoryDTO)
                .collect(Collectors.toList()));

        return orderDTO;
    }

    public List<OrderDTO> getOrderHistory(Integer userId) {
        List<Order> orders = orderRepository.findByUserId(userId);
        if (orders.isEmpty()) {
            throw new OrderNotFoundException("No orders found for user ID: " + userId);
        }
        return orders.stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Transactional
    public void deleteOrder(Integer orderId) {
        if (!orderRepository.existsById(orderId)) {
            throw new OrderNotFoundException("Order not found with ID: " + orderId);
        }
        orderItemRepository.deleteByOrder_OrderId(orderId);
        orderHistoryRepository.deleteByOrder_OrderId(orderId);
        orderRepository.deleteById(orderId);
    }

    private OrderDTO convertToDTO(Order order) {
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getOrderId());
        orderDTO.setUserId(order.getUserId());
        orderDTO.setTotalAmount(order.getTotalAmount());
        orderDTO.setOrderStatus(order.getOrderStatus());
        orderDTO.setDeliveryAddressId(order.getDeliveryAddressId());
        orderDTO.setDeliveryDate(order.getDeliveryDate());
        orderDTO.setCreatedAt(order.getCreatedAt());
        return orderDTO;
    }

    private OrderItemDTO convertToOrderItemDTO(OrderItem orderItem) {
        OrderItemDTO orderItemDTO = new OrderItemDTO();
        orderItemDTO.setOrderItemId(orderItem.getOrderItemId());
        orderItemDTO.setProductId(orderItem.getProductId());
        orderItemDTO.setQuantity(orderItem.getQuantity());

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(orderItem.getProductId());
        if (productResponse.hasBody()) {
            ProductDTO product = productResponse.getBody();
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setPrice(product.getOldPrice());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTO.setFinalPrice(product.getNewPrice());
        } else {
            orderItemDTO.setProductName("Unknown Product");
            orderItemDTO.setPrice(0.0);
            orderItemDTO.setDiscount(0.0);
            orderItemDTO.setFinalPrice(0.0);
        }
        return orderItemDTO;
    }

    private OrderHistoryDTO convertToOrderHistoryDTO(OrderHistory orderHistory) {
        OrderHistoryDTO orderHistoryDTO = new OrderHistoryDTO();
        orderHistoryDTO.setOrderHistoryId(orderHistory.getOrderHistoryId());
        orderHistoryDTO.setOrderId(orderHistory.getOrder().getOrderId());
        orderHistoryDTO.setUserId(orderHistory.getUserId());
        orderHistoryDTO.setOrderStatus(orderHistory.getOrderStatus());
        return orderHistoryDTO;
    }
}


package com.genckart.clients;

import com.genckart.dto.CartDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

import java.util.List;

@FeignClient(name = "CartService", url = "http://localhost:8080/cart")
public interface CartClient {
    @GetMapping("/user/{userId}")
    ResponseEntity<List<CartDTO>> getCartByUserId(@PathVariable Integer userId);
}










package com.genckart.service.Impl;

import com.genckart.clients.CartClient;
import com.genckart.clients.ProductClient;
import com.genckart.clients.UserClient;
import com.genckart.dto.*;
import com.genckart.entity.*;
import com.genckart.exception.OrderNotFoundException;
import com.genckart.repository.OrderHistoryRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.repository.OrderRepository;
import com.genckart.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;
    private final OrderItemRepository orderItemRepository;
    private final OrderHistoryRepository orderHistoryRepository;
    private final UserClient userClient;
    private final ProductClient productClient;
    private final CartClient cartClient;

    @Override
    public OrderDTO placeOrderFromCart(Integer userId) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract CartDTO from ResponseEntity
        ResponseEntity<CartDTO> cartResponse = cartClient.getCartByUserId(userId);
        if (!cartResponse.hasBody()) {
            throw new OrderNotFoundException("Cart not found for user ID: " + userId);
        }
        CartDTO cart = cartResponse.getBody();

        Order order = new Order();
        order.setUserId(userId);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        List<OrderItem> orderItems = cart.getCartItems().stream()
                .map(item -> {
                    OrderItem orderItem = new OrderItem();
                    orderItem.setOrder(order);
                    orderItem.setProductId(item.getProductId());
                    orderItem.setQuantity(item.getQuantity());
                    return orderItem;
                }).collect(Collectors.toList());

        Order savedOrder = orderRepository.save(order);
        orderItems.forEach(item -> item.setOrder(savedOrder));
        orderItemRepository.saveAll(orderItems);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        // Extract UserDTO from ResponseEntity
        ResponseEntity<UserDTO> userResponse = userClient.getUserById(userId);
        if (!userResponse.hasBody()) {
            throw new OrderNotFoundException("User not found for ID: " + userId);
        }
        UserDTO user = userResponse.getBody();

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(productId);
        if (!productResponse.hasBody()) {
            throw new OrderNotFoundException("Product not found for ID: " + productId);
        }
        ProductDTO product = productResponse.getBody();

        double productPrice = product.getNewPrice();
        double discountPercentage = product.getDiscount();
        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
        double finalPrice = discountedPrice * quantity;

        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(finalPrice);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        Order savedOrder = orderRepository.save(order);

        OrderItem orderItem = new OrderItem();
        orderItem.setOrder(savedOrder);
        orderItem.setProductId(productId);
        orderItem.setQuantity(quantity);
        orderItemRepository.save(orderItem);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO getOrderDetails(Integer orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + orderId));

        List<OrderItem> orderItems = orderItemRepository.findByOrderId(orderId);
        List<OrderHistory> orderHistory = orderHistoryRepository.findByOrderId(orderId);

        OrderDTO orderDTO = convertToDTO(order);
        orderDTO.setOrderItems(orderItems.stream()
                .map(this::convertToOrderItemDTO)
                .collect(Collectors.toList()));
        orderDTO.setOrderHistory(orderHistory.stream()
                .map(this::convertToOrderHistoryDTO)
                .collect(Collectors.toList()));

        return orderDTO;
    }

    @Transactional
    public void deleteOrder(Integer orderId) {
        if (!orderRepository.existsById(orderId)) {
            throw new OrderNotFoundException("Order not found with ID: " + orderId);
        }
        orderItemRepository.deleteByOrder_OrderId(orderId);
        orderHistoryRepository.deleteByOrder_OrderId(orderId);
        orderRepository.deleteById(orderId);
    }

    private OrderDTO convertToDTO(Order order) {
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getOrderId());
        orderDTO.setUserId(order.getUserId());
        orderDTO.setTotalAmount(order.getTotalAmount());
        orderDTO.setOrderStatus(order.getOrderStatus());
        orderDTO.setDeliveryAddressId(order.getDeliveryAddressId());
        orderDTO.setDeliveryDate(order.getDeliveryDate());
        orderDTO.setCreatedAt(order.getCreatedAt());
        return orderDTO;
    }

    private OrderItemDTO convertToOrderItemDTO(OrderItem orderItem) {
        OrderItemDTO orderItemDTO = new OrderItemDTO();
        orderItemDTO.setOrderItemId(orderItem.getOrderItemId());
        orderItemDTO.setProductId(orderItem.getProductId());
        orderItemDTO.setQuantity(orderItem.getQuantity());

        // Extract ProductDTO from ResponseEntity
        ResponseEntity<ProductDTO> productResponse = productClient.getProductById(orderItem.getProductId());
        if (productResponse.hasBody()) {
            ProductDTO product = productResponse.getBody();
            orderItemDTO.setProductName(product.getName());
            orderItemDTO.setPrice(product.getOldPrice());
            orderItemDTO.setDiscount(product.getDiscount());
            orderItemDTO.setFinalPrice(product.getNewPrice());
        } else {
            orderItemDTO.setProductName("Unknown Product");
            orderItemDTO.setPrice(0.0);
            orderItemDTO.setDiscount(0.0);
            orderItemDTO.setFinalPrice(0.0);
        }
        return orderItemDTO;
    }

    private OrderHistoryDTO convertToOrderHistoryDTO(OrderHistory orderHistory) {
        OrderHistoryDTO orderHistoryDTO = new OrderHistoryDTO();
        orderHistoryDTO.setOrderHistoryId(orderHistory.getOrderHistoryId());
        orderHistoryDTO.setOrderId(orderHistory.getOrder().getOrderId());
        orderHistoryDTO.setUserId(orderHistory.getUserId());
        orderHistoryDTO.setOrderStatus(orderHistory.getOrderStatus());
        return orderHistoryDTO;
    }
}





















{
    "orderId": 3,
    "userId": 3,
    "totalAmount": 2700.0,
    "orderStatus": "SHIPPED",
    "deliveryAddressId": 103,
    "deliveryDate": "2025-02-24",
    "createdAt": "2025-02-15T06:54:36.000+00:00",
    "updatedAt": null,
    "orderItems": [
        {
            "orderItemId": null,
            "productId": 5,
            "productName": null,
            "quantity": 2,
            "price": 500.0,
            "discount": null,
            "finalPrice": null,
            "createdAt": null
        },
        {
            "orderItemId": null,
            "productId": 6,
            "productName": null,
            "quantity": 3,
            "price": 600.0,
            "discount": null,
            "finalPrice": null,
            "createdAt": null
        }
    ],
    "orderHistory": [
        {
            "orderHistoryId": 3,
            "orderId": 3,
            "userId": 3,
            "orderStatus": "SHIPPED",
            "statusChangedAt": null
        }
    ]
}


  "productName": null,
            "discount": null,
            "finalPrice": null,
            "createdAt": null
why are all these null fetch these from product table and createdat should is not inserted value it should show when the order is placed according to time zone









package com.genckart.repository;

import com.genckart.entity.OrderHistory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Repository
public interface OrderHistoryRepository extends JpaRepository<OrderHistory, Integer> {

    @Query("DELETE FROM OrderHistory oh WHERE oh.order.orderId = :orderId")
    List<OrderHistory> findByOrderId(Integer orderId);

    @Modifying
    @Transactional
    @Query("DELETE FROM OrderHistory oh WHERE oh.order.orderId = :orderId")
    void deleteByOrder_OrderId(@Param("orderId") Integer OrderId);

}

package com.genckart.repository;

import com.genckart.entity.OrderItem;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Repository
public interface OrderItemRepository extends JpaRepository<OrderItem, Integer> {

    @Query("SELECT oi FROM OrderItem oi WHERE oi.order.orderId = :orderId")
    List<OrderItem> findByOrderId(Integer orderId);

    @Modifying
    @Transactional
    @Query("DELETE FROM OrderItem oi WHERE oi.order.orderId = :orderId")
    void deleteByOrder_OrderId(@Param("orderId") Integer OrderId);
}



package com.genckart.service.Impl;

import com.genckart.clients.CartClient;
import com.genckart.clients.ProductClient;
import com.genckart.clients.UserClient;
import com.genckart.dto.*;
import com.genckart.entity.*;
import com.genckart.exception.OrderNotFoundException;
import com.genckart.repository.OrderHistoryRepository;
import com.genckart.repository.OrderItemRepository;
import com.genckart.repository.OrderRepository;
import com.genckart.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {

    private final OrderRepository orderRepository;

    private final OrderItemRepository orderItemRepository;

    private final OrderHistoryRepository orderHistoryRepository;

    private final UserClient userClient;

    private final ProductClient productClient;

    private final CartClient cartClient;

    @Override
    public OrderDTO placeOrderFromCart(Integer userId) {
        UserDTO user = userClient.getUserById(userId);
        CartDTO cart = cartClient.getCartByUserId(userId);

        Order order = new Order();
        order.setUserId(userId);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        List<OrderItem> orderItems = cart.getCartItems().stream()
                .map(item -> {
                    ProductDTO product = productClient.getProductById(item.getProductId());
                    double productPrice = product.getNewPrice();
                    double discountPercentage = product.getDiscount(); // Discount in percentage
                    double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
                    double finalPrice = discountedPrice * item.getQuantity();

                    OrderItem orderItem = new OrderItem();
                    orderItem.setOrder(order);
                    orderItem.setProductId(item.getProductId());
                    orderItem.setQuantity(item.getQuantity());
                    orderItem.setPrice(productPrice); // Original price
                    orderItem.setDiscount(discountPercentage); // Discount percentage
                    orderItem.setFinalPrice(finalPrice); // Computed final price

                    return orderItem;
                }).collect(Collectors.toList());

        // Calculate total amount based on discounted prices
        double totalAmount = orderItems.stream().mapToDouble(OrderItem::getFinalPrice).sum();
        order.setTotalAmount(totalAmount);

        Order savedOrder = orderRepository.save(order);
        orderItems.forEach(item -> item.setOrder(savedOrder)); // Set saved order for items
        orderItemRepository.saveAll(orderItems);

        // Save order history
        OrderHistory orderHistory = new OrderHistory();
        orderHistory.getOrder().setOrderId(savedOrder.getOrderId());
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    public OrderDTO placeOrderFromProductDetail(Integer userId, Integer productId, Integer quantity) {
        UserDTO user = userClient.getUserById(userId);
        ProductDTO product = productClient.getProductById(productId);

        double productPrice = product.getNewPrice();
        double discountPercentage = product.getDiscount(); // Discount stored in percentage
        double discountedPrice = productPrice - (productPrice * discountPercentage / 100);
        double finalPrice = discountedPrice * quantity;

        Order order = new Order();
        order.setUserId(userId);
        order.setTotalAmount(finalPrice);
        order.setOrderStatus("PENDING");
        order.setDeliveryAddressId(user.getAddressId());
        order.setDeliveryDate(LocalDate.now().plusDays(7));

        Order savedOrder = orderRepository.save(order);

        OrderItem orderItem = new OrderItem();
        orderItem.setOrder(savedOrder);
        orderItem.setProductId(productId);
        orderItem.setQuantity(quantity);
        orderItem.setPrice(productPrice); // Original price
        orderItem.setDiscount(discountPercentage); // Discount in percentage
        orderItem.setFinalPrice(finalPrice); // Computed final price
        orderItemRepository.save(orderItem);

        OrderHistory orderHistory = new OrderHistory();
        orderHistory.setOrder(savedOrder);
        orderHistory.setUserId(userId);
        orderHistory.setOrderStatus("PENDING");
        orderHistoryRepository.save(orderHistory);

        return convertToDTO(savedOrder);
    }

    @Transactional
    public void updateOrderStatus(Integer orderId, String newStatus) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + orderId));

        order.setOrderStatus(newStatus);
        orderRepository.save(order);

        OrderHistory orderHistory = new OrderHistory();
        order.setOrderId(orderId);
        orderHistory.setOrder(order);
        orderHistory.setUserId(order.getUserId());
        orderHistory.setOrderStatus(newStatus);
        orderHistoryRepository.save(orderHistory);
    }

    @Scheduled(cron = "0 0 0 * * ?")
    public void checkAndUpdateOrderStatus() {
        List<Order> activeOrders = orderRepository.findByOrderStatusNot("DELIVERED");
        for (Order order : activeOrders) {
            if (LocalDate.now().isAfter(order.getDeliveryDate().minusDays(2)) && order.getOrderStatus().equals("PENDING")) {
                updateOrderStatus(order.getOrderId(), "IN_PROGRESS");
            } else if (LocalDate.now().isAfter(order.getDeliveryDate()) && order.getOrderStatus().equals("IN_PROGRESS")) {
                updateOrderStatus(order.getOrderId(), "DELIVERED");
            }
        }
    }


    public List<OrderDTO> getOrderHistory(Integer userId) {
        List<Order> orders = orderRepository.findByUserId(userId);
        if (orders.isEmpty()) {
            throw new OrderNotFoundException("No orders found for user ID: " + userId);
        }
        return orders.stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    public OrderDTO getOrderDetails(Integer orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new OrderNotFoundException("Order not found with ID: " + orderId));

        List<OrderItem> orderItems = orderItemRepository.findByOrderId(orderId);
        List<OrderHistory> orderHistory = orderHistoryRepository.findByOrderId(orderId);

        OrderDTO orderDTO = convertToDTO(order);
        orderDTO.setOrderItems(orderItems.stream()
                .map(this::convertToOrderItemDTO)
                .collect(Collectors.toList()));
        orderDTO.setOrderHistory(orderHistory.stream()
                .map(this::convertToOrderHistoryDTO)
                .collect(Collectors.toList()));

        return orderDTO;
    }

    public void deleteOrder(Integer orderId) {
        if (!orderRepository.existsById(orderId)) {
            throw new OrderNotFoundException("Order not found with ID: " + orderId);
        }

        orderItemRepository.deleteByOrder_OrderId(orderId);
        orderHistoryRepository.deleteByOrder_OrderId(orderId);
        orderRepository.deleteById(orderId);
    }

    private OrderDTO convertToDTO(Order order) {
        OrderDTO orderDTO = new OrderDTO();
        orderDTO.setOrderId(order.getOrderId());
        orderDTO.setUserId(order.getUserId());
        orderDTO.setTotalAmount(order.getTotalAmount());
        orderDTO.setOrderStatus(order.getOrderStatus());
        orderDTO.setDeliveryAddressId(order.getDeliveryAddressId());
        orderDTO.setDeliveryDate(order.getDeliveryDate());
        orderDTO.setCreatedAt(order.getCreatedAt());
        return orderDTO;
    }

    private OrderItemDTO convertToOrderItemDTO(OrderItem orderItem) {
        OrderItemDTO orderItemDTO = new OrderItemDTO();
        orderItemDTO.setProductId(orderItem.getProductId());
        orderItemDTO.setQuantity(orderItem.getQuantity());
        orderItemDTO.setPrice(orderItem.getPrice());
        return orderItemDTO;
    }

    private OrderHistoryDTO convertToOrderHistoryDTO(OrderHistory orderHistory) {
        OrderHistoryDTO orderHistoryDTO = new OrderHistoryDTO();
        orderHistoryDTO.setOrderHistoryId(orderHistory.getOrderHistoryId());
        orderHistoryDTO.setOrderId(orderHistory.getOrder().getOrderId());
        orderHistoryDTO.setUserId(orderHistory.getUserId());
        orderHistoryDTO.setOrderStatus(orderHistory.getOrderStatus());
        return orderHistoryDTO;
    }
}


package com.genckart.controller;

import com.genckart.dto.OrderDTO;
import com.genckart.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/orders")
public class OrderController {

    @Autowired
    private OrderService orderService;

    @PostMapping("/cart/{userId}")
    public ResponseEntity<OrderDTO> placeOrderFromCart(@PathVariable Integer userId) {
        OrderDTO savedOrder = orderService.placeOrderFromCart(userId);
        return new ResponseEntity<>(savedOrder, HttpStatus.CREATED);
    }

    @PostMapping("/product/{userId}/{productId}/{quantity}")
    public ResponseEntity<OrderDTO> placeOrderFromProductDetail(
            @PathVariable Integer userId,
            @PathVariable Integer productId,
            @PathVariable Integer quantity) {
        OrderDTO savedOrder = orderService.placeOrderFromProductDetail(userId, productId, quantity);
        return new ResponseEntity<>(savedOrder, HttpStatus.CREATED);
    }

    @GetMapping("/history/{userId}")
    public ResponseEntity<List<OrderDTO>> getOrderHistory(@PathVariable Integer userId) {
        List<OrderDTO> orders = orderService.getOrderHistory(userId);
        return new ResponseEntity<>(orders, HttpStatus.OK);
    }

    @GetMapping("/{orderId}")
    public ResponseEntity<OrderDTO> getOrderDetails(@PathVariable Integer orderId) {
        OrderDTO order = orderService.getOrderDetails(orderId);
        return new ResponseEntity<>(order, HttpStatus.OK);
    }

    @DeleteMapping("/delete/{orderId}")
    public ResponseEntity<String> deleteOrder(@PathVariable Integer orderId){
        orderService.deleteOrder(orderId);
        return ResponseEntity.ok("Order deleted successfully");
    }
}





CREATE DATABASE productDb;

USE productDb;

CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    new_price DOUBLE NOT NULL,
    old_price DOUBLE NOT NULL,
    gender VARCHAR(255),
    quantity INT,
    rating DOUBLE,
    brand VARCHAR(255),
    popularity VARCHAR(255),
    color VARCHAR(255),
    description LONGTEXT,
    image1 VARCHAR(255),
    image2 VARCHAR(255),
    image3 VARCHAR(255),
    discount DOUBLE,
    highlights_shipping_fee DOUBLE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    category_name INT NOT NULL
);

CREATE TABLE reviews (
    review_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    rating INT NOT NULL,
    review_text VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE categories (
    category_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    parent_id INT
);

INSERT INTO products (name, new_price, old_price, gender, quantity, rating, brand, popularity, color, description, image1, image2, image3, discount, highlights_shipping_fee, category_name) VALUES
('Product 1', 100.0, 120.0, 'Unisex', 10, 4.5, 'Brand A', 'High', 'Red', 'Description of Product 1', 'image1.jpg', 'image2.jpg', 'image3.jpg', 10.0, 5.0, 1),
('Product 2', 200.0, 220.0, 'Male', 20, 4.0, 'Brand B', 'Medium', 'Blue', 'Description of Product 2', 'image1.jpg', 'image2.jpg', 'image3.jpg', 15.0, 10.0, 2),
('Product 3', 300.0, 320.0, 'Female', 30, 3.5, 'Brand C', 'Low', 'Green', 'Description of Product 3', 'image1.jpg', 'image2.jpg', 'image3.jpg', 20.0, 15.0, 3),
('Product 4', 400.0, 420.0, 'Unisex', 40, 4.5, 'Brand D', 'High', 'Yellow', 'Description of Product 4', 'image1.jpg', 'image2.jpg', 'image3.jpg', 25.0, 20.0, 4),
('Product 5', 500.0, 520.0, 'Male', 50, 4.0, 'Brand E', 'Medium', 'Black', 'Description of Product 5', 'image1.jpg', 'image2.jpg', 'image3.jpg', 30.0, 25.0, 5),
('Product 6', 600.0, 620.0, 'Female', 60, 3.5, 'Brand F', 'Low', 'White', 'Description of Product 6', 'image1.jpg', 'image2.jpg', 'image3.jpg', 35.0, 30.0, 6),
('Product 7', 700.0, 720.0, 'Unisex', 70, 4.5, 'Brand G', 'High', 'Purple', 'Description of Product 7', 'image1.jpg', 'image2.jpg', 'image3.jpg', 40.0, 35.0, 7),
('Product 8', 800.0, 820.0, 'Male', 80, 4.0, 'Brand H', 'Medium', 'Orange', 'Description of Product 8', 'image1.jpg', 'image2.jpg', 'image3.jpg', 45.0, 40.0, 8),
('Product 9', 900.0, 920.0, 'Female', 90, 3.5, 'Brand I', 'Low', 'Pink', 'Description of Product 9', 'image1.jpg', 'image2.jpg', 'image3.jpg', 50.0, 45.0, 9),
('Product 10', 1000.0, 1020.0, 'Unisex', 100, 4.5, 'Brand J', 'High', 'Brown', 'Description of Product 10', 'image1.jpg', 'image2.jpg', 'image3.jpg', 55.0, 50.0, 10),
('Product 11', 1100.0, 1120.0, 'Male', 110, 4.0, 'Brand K', 'Medium', 'Gray', 'Description of Product 11', 'image1.jpg', 'image2.jpg', 'image3.jpg', 60.0, 55.0, 11),
('Product 12', 1200.0, 1220.0, 'Female', 120, 3.5, 'Brand L', 'Low', 'Cyan', 'Description of Product 12', 'image1.jpg', 'image2.jpg', 'image3.jpg', 65.0, 60.0, 12),
('Product 13', 1300.0, 1320.0, 'Unisex', 130, 4.5, 'Brand M', 'High', 'Magenta', 'Description of Product 13', 'image1.jpg', 'image2.jpg', 'image3.jpg', 70.0, 65.0, 13),
('Product 14', 1400.0, 1420.0, 'Male', 140, 4.0, 'Brand N', 'Medium', 'Lime', 'Description of Product 14', 'image1.jpg', 'image2.jpg', 'image3.jpg', 75.0, 70.0, 14),
('Product 15', 1500.0, 1520.0, 'Female', 150, 3.5, 'Brand O', 'Low', 'Teal', 'Description of Product 15', 'image1.jpg', 'image2.jpg', 'image3.jpg', 80.0, 75.0, 15),
('Product 16', 1600.0, 1620.0, 'Unisex', 160, 4.5, 'Brand P', 'High', 'Navy', 'Description of Product 16', 'image1.jpg', 'image2.jpg', 'image3.jpg', 85.0, 80.0, 16),
('Product 17', 1700.0, 1720.0, 'Male', 170, 4.0, 'Brand Q', 'Medium', 'Olive', 'Description of Product 17', 'image1.jpg', 'image2.jpg', 'image3.jpg', 90.0, 85.0, 17),
('Product 18', 1800.0, 1820.0, 'Female', 180, 3.5, 'Brand R', 'Low', 'Maroon', 'Description of Product 18', 'image1.jpg', 'image2.jpg', 'image3.jpg', 95.0, 90.0, 18),
('Product 19', 1900.0, 1920.0, 'Unisex', 190, 4.5, 'Brand S', 'High', 'Gold', 'Description of Product 19', 'image1.jpg', 'image2.jpg', 'image3.jpg', 100.0, 95.0, 19),
('Product 20', 2000.0, 2020.0, 'Male', 200, 4.0, 'Brand T', 'Medium', 'Silver', 'Description of Product 20', 'image1.jpg', 'image2.jpg', 'image3.jpg', 105.0, 100.0, 20);

INSERT INTO reviews (user_id, product_id, rating, review_text) VALUES
(1, 1, 5, 'Great product!'),
(2, 2, 4, 'Very good quality.'),
(3, 3, 3, 'Average product.'),
(4, 4, 5, 'Excellent!'),
(5, 5, 4, 'Good value for money.'),
(6, 6, 3, 'Not bad.'),
(7, 7, 5, 'Highly recommend.'),
(8, 8, 4, 'Satisfied with the purchase.'),
(9, 9, 3, 'Could be better.'),
(10, 10, 5, 'Fantastic product!'),
(11, 11, 4, 'Worth the price.'),
(12, 12, 3, 'Just okay.'),
(13, 13, 5, 'Loved it!'),
(14, 14, 4, 'Pretty good.'),
(15, 15, 3, 'Decent quality.'),
(16, 16, 5, 'Amazing product!'),
(17, 17, 4, 'Quite good.'),
(18, 18, 3, 'It’s alright.'),
(19, 19, 5, 'Superb!'),
(20, 20, 4, 'Nice product.');

INSERT INTO categories (name, parent_id) VALUES
('Electronics', NULL),
('Clothing', NULL),
('Books', NULL),
('Home & Kitchen', NULL),
('Sports & Outdoors', NULL),
('Beauty & Personal Care', NULL),
('Toys & Games', NULL),
('Automotive', NULL),
('Health & Household', NULL),
('Grocery', NULL),
('Pet Supplies', NULL),
('Office Products', NULL),
('Garden & Outdoor', NULL),
('Tools & Home Improvement', NULL),
('Baby', NULL),
('Musical Instruments', NULL),
('Industrial & Scientific', NULL),
('Software', NULL),
('Video Games', NULL),
('Jewelry', NULL);

drop table products;
drop table reviews;
drop table categories;

drop database productDb;

select * from products;


create database cartdb;

use cartdb;

CREATE TABLE Cart (
    cart_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity > 0),
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO Cart (user_id, product_id, quantity, added_at) VALUES
(1, 1, 2, '2025-02-10 10:00:00'),
(2, 2, 1, '2025-02-10 11:00:00'),
(3, 3, 3, '2025-02-10 12:00:00'),
(4, 4, 1, '2025-02-10 13:00:00'),
(5, 5, 2, '2025-02-10 14:00:00'),
(6, 6, 1, '2025-02-10 15:00:00'),
(7, 7, 2, '2025-02-10 16:00:00'),
(8, 8, 3, '2025-02-10 17:00:00'),
(9, 9, 1, '2025-02-10 18:00:00'),
(10, 10, 2, '2025-02-10 19:00:00'),
(11, 11, 1, '2025-02-10 20:00:00'),
(12, 12, 2, '2025-02-10 21:00:00'),
(13, 13, 3, '2025-02-10 22:00:00'),
(14, 14, 1, '2025-02-10 23:00:00'),
(15, 15, 2, '2025-02-11 00:00:00'),
(16, 16, 1, '2025-02-11 01:00:00'),
(17, 17, 2, '2025-02-11 02:00:00'),
(18, 18, 3, '2025-02-11 03:00:00'),
(19, 19, 1, '2025-02-11 04:00:00'),
(20, 20, 2, '2025-02-11 05:00:00');

drop table Cart;

drop table cart_items;


CREATE TABLE cart_items (
    cart_item_id INT AUTO_INCREMENT PRIMARY KEY,
    cart_id INT NOT NULL,
    user_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    product_name VARCHAR(255) NOT NULL,
    product_price DOUBLE NOT NULL,
    FOREIGN KEY (cart_id) REFERENCES cart(cart_id)
);

INSERT INTO cart_items (cart_id, user_id, product_id, quantity, product_name, product_price) VALUES
(1, 1, 1, 2, 'Product 1', 100.0),
(2, 2, 2, 1, 'Product 2', 200.0),
(3, 3, 3, 3, 'Product 3', 300.0),
(4, 4, 4, 1, 'Product 4', 400.0),
(5, 5, 5, 2, 'Product 5', 500.0),
(6, 6, 6, 1, 'Product 6', 600.0),
(7, 7, 7, 2, 'Product 7', 700.0),
(8, 8, 8, 3, 'Product 8', 800.0),
(9, 9, 9, 1, 'Product 9', 900.0),
(10, 10, 10, 2, 'Product 10', 1000.0),
(11, 11, 11, 1, 'Product 11', 1100.0),
(12, 12, 12, 2, 'Product 12', 1200.0),
(13, 13, 13, 3, 'Product 13', 1300.0),
(14, 14, 14, 1, 'Product 14', 1400.0),
(15, 15, 15, 2, 'Product 15', 1500.0),
(16, 16, 16, 1, 'Product 16', 1600.0),
(17, 17, 17, 2, 'Product 17', 1700.0),
(18, 18, 18, 3, 'Product 18', 1800.0),
(19, 19, 19, 1, 'Product 19', 1900.0),
(20, 20, 20, 2, 'Product 20', 2000.0);

select * from cart;
select * from cart_items;

 CREATE DATABASE userDb;



USE userDb;



CREATE TABLE users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    phone_number VARCHAR(25) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL
);



CREATE TABLE user_preferences (
    preference_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    category_id INT,
    brand VARCHAR(255),
    min_price DOUBLE,
    max_price DOUBLE,
    gender VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);



CREATE TABLE address (
    address_id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    street VARCHAR(255) NOT NULL,
    city VARCHAR(255) NOT NULL,
    state VARCHAR(255) NOT NULL,
    postal_code VARCHAR(20) NOT NULL,
    country VARCHAR(100) NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);





drop table users;
drop table address;
drop table user_preferences;



INSERT INTO users (name, email, phone_number, password_hash, role) VALUES
('John Doe', 'john.doe@example.com', '1234567890', 'password123', 'USER'),
('Jane Smith', 'jane.smith@example.com', '0987654321', 'password456', 'USER'),
('Alice Johnson', 'alice.johnson@example.com', '1122334455', 'password789', 'USER'),
('Bob Brown', 'bob.brown@example.com', '2233445566', 'password101', 'USER'),
('Charlie Davis', 'charlie.davis@example.com', '3344556677', 'password202', 'USER'),
('David Evans', 'david.evans@example.com', '4455667788', 'password303', 'USER'),
('Eva Green', 'eva.green@example.com', '5566778899', 'password404', 'USER'),
('Frank Harris', 'frank.harris@example.com', '6677889900', 'password505', 'USER'),
('Grace Lee', 'grace.lee@example.com', '7788990011', 'password606', 'USER'),
('Hank Miller', 'hank.miller@example.com', '8899001122', 'password707', 'USER'),
('Ivy Nelson', 'ivy.nelson@example.com', '9900112233', 'password808', 'USER'),
('Jack Owens', 'jack.owens@example.com', '0011223344', 'password909', 'USER'),
('Kara Perez', 'kara.perez@example.com', '1122334456', 'password010', 'USER'),
('Liam Quinn', 'liam.quinn@example.com', '2233445567', 'password111', 'USER'),
('Mia Roberts', 'mia.roberts@example.com', '3344556678', 'password212', 'USER'),
('Noah Scott', 'noah.scott@example.com', '4455667789', 'password313', 'USER'),
('Olivia Turner', 'olivia.turner@example.com', '5566778890', 'password414', 'USER'),
('Paul Walker', 'paul.walker@example.com', '6677889901', 'password515', 'USER'),
('Quinn Young', 'quinn.young@example.com', '7788990012', 'password616', 'USER'),
('Rachel Zane', 'rachel.zane@example.com', '8899001123', 'password717', 'USER');



INSERT INTO user_preferences (user_id, category_id, brand, min_price, max_price, gender) VALUES
(1, 2, 'Nike', 50, 200, 'Male'),
(2, 3, 'Adidas', 100, 300, 'Female'),
(3, 4, 'Puma', 150, 400, 'Male'),
(4, 5, 'Reebok', 200, 500, 'Female'),
(5, 6, 'Under Armour', 250, 600, 'Male'),
(6, 7, 'New Balance', 300, 700, 'Female'),
(7, 8, 'Asics', 350, 800, 'Male'),
(8, 9, 'Skechers', 400, 900, 'Female'),
(9, 10, 'Converse', 450, 1000, 'Male'),
(10, 11, 'Vans', 500, 1100, 'Female'),
(11, 12, 'Fila', 550, 1200, 'Male'),
(12, 13, 'Brooks', 600, 1300, 'Female'),
(13, 14, 'Saucony', 650, 1400, 'Male'),
(14, 15, 'Mizuno', 700, 1500, 'Female'),
(15, 16, 'Hoka One One', 750, 1600, 'Male'),
(16, 17, 'Merrell', 800, 1700, 'Female'),
(17, 18, 'Salomon', 850, 1800, 'Male'),
(18, 19, 'Altra', 900, 1900, 'Female'),
(19, 20, 'La Sportiva', 950, 2000, 'Male'),
(20, 21, 'Inov-8', 1000, 2100, 'Female');



INSERT INTO address (user_id, street, city, state, postal_code, country) VALUES
(1, '123 Main St', 'Tambaram', 'TN', '600001', 'India'),
(2, '456 Elm St', 'Chennai', 'TN', '600002', 'India'),
(3, '789 Oak St', 'Madurai', 'TN', '600003', 'India'),
(4, '101 Pine St', 'Coimbatore', 'TN', '600004', 'India'),
(5, '202 Maple St', 'Salem', 'TN', '600005', 'India'),
(6, '303 Birch St', 'Trichy', 'TN', '600006', 'India'),
(7, '404 Cedar St', 'Erode', 'TN', '600007', 'India'),
(8, '505 Walnut St', 'Vellore', 'TN', '600008', 'India'),
(9, '606 Chestnut St', 'Tirunelveli', 'TN', '600009', 'India'),
(10, '707 Ash St', 'Thanjavur', 'TN', '600010', 'India'),
(11, '808 Redwood St', 'Kanchipuram', 'TN', '600011', 'India'),
(12, '909 Sequoia St', 'Nagercoil', 'TN', '600012', 'India'),
(13, '1010 Spruce St', 'Dindigul', 'TN', '600013', 'India'),
(14, '1111 Fir St', 'Theni', 'TN', '600014', 'India'),
(15, '1212 Hemlock St', 'Karur', 'TN', '600015', 'India'),
(16, '1313 Cypress St', 'Nagapattinam', 'TN', '600016', 'India'),
(17, '1414 Willow St', 'Pudukkottai', 'TN', '600017', 'India'),
(18, '1515 Poplar St', 'Ramanathapuram', 'TN', '600018', 'India'),
(19, '1616 Sycamore St', 'Sivaganga', 'TN', '600019', 'India'),
(20, '1717 Magnolia St', 'Tiruvannamalai', 'TN', '600020', 'India');


BACKEND: Order Management

Acceptance Criteria


AC 1: Place Order API (POST /orders)

GIVEN valid order details and a user ID, WHEN a user places an order, THEN the order details are saved securely in the database, and a confirmation response is returned.

AC 2: View Order History API (GET /orders/history)

GIVEN a valid user ID, WHEN a request is made to view the order history, THEN the API returns a list of past orders, including order date, total amount, and order status.

AC 3:  View Order Details API (GET /orders/{orderId})

GIVEN a valid order ID, WHEN a request is made to view the order details, THEN the API returns detailed information about the order, including product names, quantities, prices, delivery address, and order status.

Description

As an End Customer,
I want to place an order,
So that I can buy the selected products.

In Scope:

Actors: End Customer

Product: Order placement, order history, and order details

Events: Placing an order, viewing order history, viewing order details

Out of Scope:

Actors: Admins, Sellers

Product: Backend data management or updates

Background: Customers can place orders for selected products, view their order history, and see detailed information about their orders. This enhances their shopping experience by providing a seamless and informative order management system.

Requirements:

Place Order:

Allow users to place an order from the cart or product detail page.

Save order details securely in the database.

View Order History:

Retrieve and display the user's order history.

Ensure the order history is user-specific and stored securely.

View Order Details:

Retrieve and display detailed information about a specific order.

Ensure the order details are user-specific and stored securely.

Backend Implementation:

Tech Stack: Spring Boot, MySQL, Spring Data JPA, Redis (for caching)

Tables Involved:

orders: Stores the details of each order placed by users.

order_items: Stores the items included in each order.

order_history: Stores the history of orders for each user.

Exception Handling:

OrderNotFoundException: Thrown when no order is found for a given order ID.

OrderHistoryNotFoundException: Thrown when no order history is found for a user.

Tasks:

Place Order API (POST /orders)

Description: Saves an order when the user places it.

Input: Order details, User ID

Output: Confirmation of order placement

View Order History API (GET /orders/history)

Description: Retrieves the user's order history.

Input: User ID

Output: List of past orders

View Order Details API (GET /orders/{orderId})

Description: Retrieves detailed information about a specific order.

Input: Order ID

Output: Detailed order information

cart microservice:

package com.genckart.Client;

import com.genckart.dto.ProductDto;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "Product-Service", url = "http://localhost:8081/products")
public interface ProductClient {
    @GetMapping("/{id}")
    public ResponseEntity<ProductDto> getProductById(@PathVariable Integer id);
}



package com.genckart.Client;

import com.genckart.dto.UserDto;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "User-Profile-Management-Service", url = "http://localhost:8082/user")
public interface UserClient {
    @GetMapping("/profile/{id}")
    public ResponseEntity<UserDto> getUserById(@PathVariable Integer id);

}


package com.genckart.Controller;

import com.genckart.Service.CartService;
import com.genckart.dto.CartDto;
import com.genckart.dto.CartItemDto;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/cart")
@RequiredArgsConstructor
public class CartController {

    private final CartService cartService;

    @GetMapping("/user/{userId}")
    public ResponseEntity<List<CartDto>> getCartByUserId(@PathVariable Integer userId) {
        List<CartDto> cart = cartService.getCartByUserId(userId);
        return new ResponseEntity<>(cart, HttpStatus.OK);
    }

    @PostMapping("/add")
    public ResponseEntity<CartItemDto> addItemToCart(@RequestBody CartItemDto cartItemDto) {
        CartItemDto addedItem = cartService.addItemToCart(cartItemDto);
        return new ResponseEntity<>(addedItem, HttpStatus.CREATED);
    }

    @PutMapping("/update/{userId}")
    public ResponseEntity<CartItemDto> updateItemToCart(@PathVariable Integer userId, @RequestBody CartItemDto cartItemDto) {
        CartItemDto updatedItem = cartService.updateItemToCart(userId, cartItemDto);
        return new ResponseEntity<>(updatedItem, HttpStatus.OK);
    }

    @DeleteMapping("/delete/{userId}/{cartItemId}")
    public ResponseEntity<Void> deleteCartItemById(@PathVariable Integer userId, @PathVariable Integer cartItemId) {
        cartService.deleteCartItemById(userId, cartItemId);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @DeleteMapping("/clear/{userId}")
    public ResponseEntity<Void> clearCart(@PathVariable Integer userId) {
        cartService.clearCart(userId);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }

    @GetMapping("/isEmpty/{userId}")
    public ResponseEntity<Boolean> isCartEmpty(@PathVariable Integer userId) {
        boolean isEmpty = cartService.isCartEmpty(userId);
        return new ResponseEntity<>(isEmpty, HttpStatus.OK);
    }

    @GetMapping("/cart-items/{cartId}")
    public ResponseEntity<List<CartItemDto>> getCartItemsByCartId(@PathVariable Integer cartId) {
        List<CartItemDto> cartItems = cartService.getCartItemsByCartId(cartId);
        return ResponseEntity.ok(cartItems);
    }
}


package com.genckart.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.List;

@Data
public class CartDto {

    private Integer cartId;
    private int userId;
    private int productId;
    private int quantity;
    private LocalDateTime addedAt;
    private String userName;
    private List<CartItemDto> cartItems;
}
package com.genckart.dto;

import lombok.Data;

@Data
public class CartItemDto {

    private Integer cartItemId;
    private Integer userId;
    private Integer productId;
    private Integer quantity;
    private String productName;
    private Double productPrice;
}

package com.genckart.dto;

import lombok.Data;

@Data
public class ProductDto {
    private Integer productId;
    private String name;
    private double newPrice;
    private int quantity;
    private String brand;
    private String color;
    private String description;
    private String image1;
    private double highlightShippingFee;
}

package com.genckart.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserDto {

    private Integer userId;

    @NotBlank(message = "Name is mandatory")
    @Size(min = 2, max = 255, message = "Name must be between 2 and 255 characters")
    private String name;

    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is mandatory")
    private String email;

    @NotBlank(message = "Phone number is mandatory")
    @Pattern(regexp = "^\\+?[0-9. ()-]{7,25}$", message = "Phone number is invalid")
    private String phoneNumber;

    @NotBlank(message = "Password is mandatory")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String passwordHash;

    private String role;
}


package com.genckart.Entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "Cart")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class Cart {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer cartId;

    @Column(nullable = false)
    private int userId;

    @Column(nullable = false)
    private int productId;

    @Column(nullable = false)
    private int quantity;

    @Column(nullable = false, updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private LocalDateTime addedAt;

}
package com.genckart.Entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "cart_items")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class CartItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer cartItemId;

    @ManyToOne
    @JoinColumn(name = "cart_id", nullable = false)
    private Cart cart;

    @Column(nullable = false)
    private Integer userId;

    @Column(nullable = false)
    private int productId;

    @Column(nullable = false)
    private int quantity;

    @Column(nullable = false)
    private String productName;

    @Column(nullable = false)
    private Double productPrice;
}
package com.genckart.Repository;

import com.genckart.Entity.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface CartItemRepository extends JpaRepository<CartItem, Integer> {
    List<CartItem> findByUserId(Integer userId);
    List<CartItem> findByUserIdAndProductId(Integer userId, Integer productId);
    CartItem findByUserIdAndCartItemId(Integer userId, Integer cartItemId);
    List<CartItem> findByCart_CartId(Integer cartId);
}
package com.genckart.Repository;

import com.genckart.Entity.Cart;
import com.genckart.Entity.CartItem;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface CartRepository extends JpaRepository<Cart, Integer> {
    Optional<Object> findByUserId(Integer userId);
}

package com.genckart.Service;

import com.genckart.dto.CartDto;
import com.genckart.dto.CartItemDto;

import java.util.List;

public interface CartService {
    List<CartDto> getCartByUserId(Integer userId);
    CartItemDto addItemToCart(CartItemDto cartItemDto);
    CartItemDto updateItemToCart(Integer userId, CartItemDto cartItemDto);
    void deleteCartItemById(Integer userId, Integer cartItemId);
    void clearCart(Integer userId);
    boolean isCartEmpty(Integer userId);
    List<CartItemDto> getCartItemsByCartId(Integer cartId);
}

package com.genckart.Service.ServiceImpl;

import com.genckart.Client.ProductClient;
import com.genckart.Client.UserClient;
import com.genckart.Entity.Cart;
import com.genckart.Entity.CartItem;
import com.genckart.Repository.CartItemRepository;
import com.genckart.Repository.CartRepository;
import com.genckart.Service.CartService;
import com.genckart.dto.CartDto;
import com.genckart.dto.CartItemDto;
import com.genckart.dto.ProductDto;
import com.genckart.dto.UserDto;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class CartServiceImpl implements CartService {

    private final CartRepository cartRepository;
    private final CartItemRepository cartItemRepository;
    private final ProductClient productServiceClient;
    private final UserClient userServiceClient;

    @Override
    public List<CartDto> getCartByUserId(Integer userId) {
        try {
            // Fetch user details
            ResponseEntity<UserDto> userResponse = userServiceClient.getUserById(userId);
            UserDto user = userResponse.getBody();
            if (user == null) {
                throw new RuntimeException("User not found");
            }

            // Fetch cart items for the user
            List<CartItemDto> cartItems = cartItemRepository.findByUserId(userId).stream()
                    .map(cartItem -> {
                        try {
                            // Fetch product details for each cart item
                            ResponseEntity<ProductDto> productResponse = productServiceClient.getProductById(cartItem.getProductId());
                            ProductDto product = productResponse.getBody();
                            if (product == null) {
                                throw new RuntimeException("Product not found");
                            }
                            CartItemDto cartItemDto = new CartItemDto();
                            cartItemDto.setCartItemId(cartItem.getCartItemId());
                            cartItemDto.setProductId(cartItem.getProductId());
                            cartItemDto.setQuantity(cartItem.getQuantity());
                            cartItemDto.setProductName(product.getName());
                            cartItemDto.setProductPrice(product.getNewPrice());
                            return cartItemDto;
                        } catch (HttpClientErrorException.NotFound e) {
                            throw new RuntimeException("Product not found with id: " + cartItem.getProductId());
                        }
                    })
                    .collect(Collectors.toList());

            // Create and return CartDto
            CartDto cartDto = new CartDto();
            cartDto.setUserId(userId);
            cartDto.setUserName(user.getName());
            cartDto.setCartItems(cartItems);
            return List.of(cartDto);
        } catch (HttpClientErrorException e) {
            throw new RuntimeException("Error fetching user or product details", e);
        }
    }

    @Override
    public CartItemDto addItemToCart(CartItemDto cartItemDto) {
        try {
            // Fetch the cart for the user
            Cart cart = (Cart) cartRepository.findByUserId(cartItemDto.getUserId())
                    .orElseThrow(() -> new RuntimeException("Cart not found for user"));

            // Convert DTO to entity
            CartItem cartItem = new CartItem();
            cartItem.setCart(cart); // Set the cart reference
            cartItem.setUserId(cartItemDto.getUserId());
            cartItem.setProductId(cartItemDto.getProductId());
            cartItem.setQuantity(cartItemDto.getQuantity());
            cartItem.setProductName(cartItemDto.getProductName());
            cartItem.setProductPrice(cartItemDto.getProductPrice());

            // Save cart item
            CartItem savedCartItem = cartItemRepository.save(cartItem);

            // Convert entity back to DTO
            cartItemDto.setCartItemId(savedCartItem.getCartItemId());
            return cartItemDto;
        } catch (Exception e) {
            throw new RuntimeException("Error adding item to cart", e);
        }
    }

    @Override
    public CartItemDto updateItemToCart(Integer userId, CartItemDto cartItemDto) {
        try {
            // Find existing cart items by userId and productId
            List<CartItem> existingCartItems = cartItemRepository.findByUserIdAndProductId(userId, cartItemDto.getProductId());

            if (existingCartItems.isEmpty()) {
                throw new RuntimeException("Cart item not found");
            }

            // Update the first cart item found (or handle multiple items as needed)
            CartItem existingCartItem = existingCartItems.get(0);
            existingCartItem.setQuantity(cartItemDto.getQuantity());

            // Save updated cart item
            CartItem updatedCartItem = cartItemRepository.save(existingCartItem);

            // Convert entity back to DTO
            cartItemDto.setCartItemId(updatedCartItem.getCartItemId());
            cartItemDto.setUserId(updatedCartItem.getUserId());
            cartItemDto.setProductId(updatedCartItem.getProductId());
            cartItemDto.setQuantity(updatedCartItem.getQuantity());

            return cartItemDto;
        } catch (Exception e) {
            throw new RuntimeException("Error updating item in cart", e);
        }
    }

    @Override
    public void deleteCartItemById(Integer userId, Integer cartItemId) {
        try {
            CartItem cartItem = cartItemRepository.findByUserIdAndCartItemId(userId, cartItemId);
            if (cartItem == null) {
                throw new RuntimeException("Cart item not found");
            }
            cartItemRepository.delete(cartItem);
        } catch (Exception e) {
            throw new RuntimeException("Error deleting cart item", e);
        }
    }

    @Override
    public void clearCart(Integer userId) {
        try {
            List<CartItem> cartItems = cartItemRepository.findByUserId(userId);
            cartItemRepository.deleteAll(cartItems);
        } catch (Exception e) {
            throw new RuntimeException("Error clearing cart", e);
        }
    }

    @Override
    public boolean isCartEmpty(Integer userId) {
        try {
            return cartItemRepository.findByUserId(userId).isEmpty();
        } catch (Exception e) {
            throw new RuntimeException("Error checking if cart is empty", e);
        }
    }

    public List<CartItemDto> getCartItemsByCartId(Integer cartId) {
        try {
            List<CartItem> cartItems = cartItemRepository.findByCart_CartId(cartId);
            return cartItems.stream()
                    .map(cartItem -> {
                        ResponseEntity<ProductDto> productResponse = productServiceClient.getProductById(cartItem.getProductId());
                        ProductDto product = productResponse.getBody();
                        if (product == null) {
                            throw new RuntimeException("Product not found");
                        }
                        CartItemDto cartItemDto = new CartItemDto();
                        cartItemDto.setCartItemId(cartItem.getCartItemId());
                        cartItemDto.setProductId(cartItem.getProductId());
                        cartItemDto.setQuantity(cartItem.getQuantity());
                        cartItemDto.setProductName(product.getName());
                        cartItemDto.setProductPrice(product.getNewPrice());
                        return cartItemDto;
                    })
                    .collect(Collectors.toList());
        } catch (Exception e) {
            throw new RuntimeException("Error fetching cart items by cart ID", e);
        }
    }
}
package com.genckart;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class CartServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(CartServiceApplication.class, args);
	}

}

product microservice:


package com.genckart.clients;
import com.genckart.dto.UserDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "User-Profile-Management-Service", url = "http://localhost:8080/user")
public interface UserClient {

    @GetMapping("/profile/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Integer id);
}

package com.genckart.controller;

import com.genckart.dto.CategoryDTO;
import com.genckart.service.CategoryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products/categories")
public class CategoryController {

    @Autowired
    private CategoryService categoryService;

    @GetMapping
    public ResponseEntity<List<CategoryDTO>> getAllCategories() {
        List<CategoryDTO> categories = categoryService.getAllCategories();
        return ResponseEntity.ok(categories);
    }

    @PostMapping
    public ResponseEntity<CategoryDTO> createCategory(@RequestBody CategoryDTO categoryDTO) {
        CategoryDTO savedCategory = categoryService.createCategory(categoryDTO);
        return ResponseEntity.ok(savedCategory);
    }

    @PutMapping("/{id}")
    public ResponseEntity<CategoryDTO> updateCategory(@PathVariable Integer id, @RequestBody CategoryDTO categoryDTO) {
        CategoryDTO updatedCategory = categoryService.updateCategory(id, categoryDTO);
        return ResponseEntity.ok(updatedCategory);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteCategory(@PathVariable Integer id) {
        categoryService.deleteCategory(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/{id}")
    public ResponseEntity<CategoryDTO> getByCategoryId(@PathVariable Integer id) {
        CategoryDTO category = categoryService.getByCategoryId(id);
        return ResponseEntity.ok(category);
    }
    @GetMapping("/name/{name}")
    public ResponseEntity<CategoryDTO> getByCategoryName(@PathVariable String name) {
        CategoryDTO category = categoryService.getByCategoryName(name);
        return ResponseEntity.ok(category);
    }
}

package com.genckart.controller;

import com.genckart.dto.ProductDTO;
import com.genckart.exception.ResourceNotFoundException;
import com.genckart.service.ProductService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    @Autowired
    private ProductService productService;

    private ResponseEntity<Object> createResponse(HttpStatus status, String message, Object data, String endpoint) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", status.value());
        body.put("message", message);
        body.put("data", data);
        body.put("endpoint", endpoint);
        return new ResponseEntity<>(body, status);
    }

    @GetMapping
    public ResponseEntity<Object> getAllProducts() {
        List<ProductDTO> products = productService.getAllProducts();
        if (products.isEmpty()) {
            return createResponse(HttpStatus.NOT_FOUND, "There are no products to display", null, "/api/products");
        }
        return createResponse(HttpStatus.OK, "Products retrieved successfully", products, "/api/products");
    }

    @GetMapping("/{id}")
    public ResponseEntity<Object> getProductById(@PathVariable Integer id) {
        try {
            ProductDTO product = productService.getProductById(id);
            return createResponse(HttpStatus.OK, "Product retrieved successfully", product, "/api/products/" + id);
        } catch (ResourceNotFoundException ex) {
            return createResponse(HttpStatus.NOT_FOUND, "Product with id " + id + " not found", null, "/api/products/" + id);
        }
    }

    @GetMapping("/search/{name}")
    public ResponseEntity<Object> getProductsByName(@PathVariable("name") String name) {
        List<ProductDTO> products = productService.getProductsByName(name);
        if (products.isEmpty()) {
            return createResponse(HttpStatus.NOT_FOUND, "Product with name " + name + " not found", null, "/api/products/search/" + name);
        }
        return createResponse(HttpStatus.OK, "Products retrieved successfully", products, "/api/products/search/" + name);
    }

    @PostMapping
    public ResponseEntity<Object> addProduct(@RequestBody ProductDTO productDTO) {
        try {
            ProductDTO savedProduct = productService.addProduct(productDTO);
            return createResponse(HttpStatus.CREATED, "Product added successfully", savedProduct, "/api/products");
        } catch (Exception ex) {
            return createResponse(HttpStatus.BAD_REQUEST, "Error: " + ex.getMessage(), null, "/api/products");
        }
    }

    @PutMapping("/{id}")
    public ResponseEntity<Object> updateProductDetails(@PathVariable Integer id, @RequestBody ProductDTO productDTO) {
        try {
            ProductDTO updatedProduct = productService.updateProductDetails(id, productDTO);
            return createResponse(HttpStatus.OK, "Product updated successfully", updatedProduct, "/api/products/" + id);
        } catch (ResourceNotFoundException ex) {
            return createResponse(HttpStatus.NOT_FOUND, "Product with id " + id + " not found", null, "/api/products/" + id);
        } catch (Exception ex) {
            return createResponse(HttpStatus.BAD_REQUEST, "Error: " + ex.getMessage(), null, "/api/products/" + id);
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Object> deleteProduct(@PathVariable Integer id) {
        try {
            productService.deleteProduct(id);
            return createResponse(HttpStatus.OK, "Product deleted successfully", null, "/api/products/" + id);
        } catch (ResourceNotFoundException ex) {
            return createResponse(HttpStatus.NOT_FOUND, "Product with id " + id + " not found", null, "/api/products/" + id);
        }
    }

    @GetMapping("/{id}/related")
    public ResponseEntity<Object> getRelatedProducts(@PathVariable Integer id) {
        List<ProductDTO> relatedProducts = productService.getRelatedProducts(id);
        if (relatedProducts.isEmpty()) {
            return createResponse(HttpStatus.NOT_FOUND, "No related products found for product with id " + id, null, "/api/products/" + id + "/related");
        }
        return createResponse(HttpStatus.OK, "Related products retrieved successfully", relatedProducts, "/api/products/" + id + "/related");
    }

    @GetMapping("/related/category/{categoryName}")
    public ResponseEntity<Object> getRelatedProductsByCategoryName(@PathVariable("categoryName") String categoryName) {
        List<ProductDTO> relatedProducts = productService.getRelatedProductsByCategoryName(categoryName);
        if (relatedProducts.isEmpty()) {
            return createResponse(HttpStatus.NOT_FOUND, "No related products found for category " + categoryName, null, "/api/products/related/category/" + categoryName);
        }
        return createResponse(HttpStatus.OK, "Related products retrieved successfully", relatedProducts, "/api/products/related/category/" + categoryName);
    }

    @GetMapping("/{id}/details")
    public ResponseEntity<Object> getProductWithReviewsAndRelatedProducts(@PathVariable Integer id) {
        try {
            ProductDTO product = productService.getProductWithReviewsAndRelatedProducts(id);
            return createResponse(HttpStatus.OK, "Product details retrieved successfully", product, "/api/products/" + id + "/details");
        } catch (ResourceNotFoundException ex) {
            return createResponse(HttpStatus.NOT_FOUND, "Product with id " + id + " not found", null, "/api/products/" + id + "/details");
        }
    }
}


package com.genckart.controller;
import com.genckart.dto.ReviewDTO;
import com.genckart.service.ReviewService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/products/reviews")
public class ReviewController {

    @Autowired
    private ReviewService reviewService;

    @GetMapping
    public ResponseEntity<List<ReviewDTO>> getAllReviews() {
        List<ReviewDTO> reviews = reviewService.getAllReviews();
        return ResponseEntity.ok(reviews);
    }

    @GetMapping("/product/{productId}")
    public ResponseEntity<List<ReviewDTO>> getReviewsByProductId(@PathVariable Integer productId) {
        List<ReviewDTO> reviews = reviewService.getReviewsByProductId(productId);
        return ResponseEntity.ok(reviews);
    }

    @GetMapping("/user/{userId}")
    public ResponseEntity<List<ReviewDTO>> getReviewsByUserId(@PathVariable Integer userId) {
        List<ReviewDTO> reviews = reviewService.getReviewsByUserId(userId);
        return ResponseEntity.ok(reviews);
    }

    @PostMapping
    public ResponseEntity<ReviewDTO> createReview(@RequestBody ReviewDTO reviewDTO) {
        ReviewDTO savedReview = reviewService.createReview(reviewDTO);
        return ResponseEntity.ok(savedReview);
    }

    @DeleteMapping("/{reviewId}")
    public ResponseEntity<Void> deleteReview(@PathVariable Integer reviewId) {
        reviewService.deleteReview(reviewId);
        return ResponseEntity.noContent().build();
    }
}
package com.genckart.dto;

import lombok.Data;

@Data
public class CategoryDTO {
    private Integer categoryId;
    private String name;
    private Integer parentId;
}

package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;

import java.util.List;

@Data
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ProductDTO {
    private Integer productId;
    private String name;
    private double newPrice;
    private double oldPrice;
    private String gender;
    private int quantity;
    private double rating;
    private String brand;
    private String popularity;
    private String color;
    private String description;
    private String image1;
    private String image2;
    private String image3;
    private double discount;
    private double highlightShippingFee;
    private String categoryName;
    private List<ReviewDTO> reviews;
    private List<ProductDTO> relatedProducts;
}

package com.genckart.dto;

import lombok.Data;

import java.sql.Timestamp;

@Data
public class ReviewDTO {
    private Integer reviewId;
    private Integer userId;
    private Integer productId;
    private int rating;
    private String reviewText;
    private UserDTO user;
    private Timestamp createdAt;// Include user details in the DTO
}
package com.genckart.dto;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserDTO {

    private Integer userId;

    @NotBlank(message = "Name is mandatory")
    @Size(min = 2, max = 255, message = "Name must be between 2 and 255 characters")
    private String name;

    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is mandatory")
    private String email;

    @NotBlank(message = "Phone number is mandatory")
    @Pattern(regexp = "^\\+?[0-9. ()-]{7,25}$", message = "Phone number is invalid")
    private String phoneNumber;

    @NotBlank(message = "Password is mandatory")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String passwordHash;

    private String role;
}

package com.genckart.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "Categories")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Min(value = 1, message = "Category ID must be greater than or equal to 1")
    private Integer categoryId;

    @Column(nullable = false)
    @NotNull(message = "Name cannot be null")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;

    private Integer parentId;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.*;
import java.sql.Timestamp;
import java.util.Set;

@Entity
@Table(name = "Products")
@Data
@NoArgsConstructor
@AllArgsConstructor
@ToString
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer productId;

    @Column(nullable = false)
    @NotNull(message = "Name cannot be null")
    @Size(min = 2, max = 100, message = "Name must be between 2 and 100 characters")
    private String name;

    @Column(nullable = false)
    @NotNull(message = "New price cannot be null")
    @Positive(message = "New price must be positive")
    private double newPrice;

    @Column(nullable = false)
    @NotNull(message = "Old price cannot be null")
    @Positive(message = "Old price must be positive")
    private double oldPrice;

    private String gender;

    @ManyToOne
    @JoinColumn(name = "category_name", nullable = false)
    @NotNull(message = "Category cannot be null")
    private Category category;

    @Min(value = 0, message = "Quantity cannot be negative")
    private int quantity;

    @Min(value = 0, message = "Rating cannot be negative")
    @Max(value = 5, message = "Rating cannot be more than 5")
    private double rating;

    private String brand;

    private String popularity;

    private String color;

    @Lob
    private String description;

    private String image1;

    private String image2;

    private String image3;

    @Min(value = 0, message = "Discount cannot be negative")
    private double discount;

    @Column(name = "highlights_shipping_fee")
    @Min(value = 0, message = "Highlight shipping fee cannot be negative")
    private double highlightShippingFee;

    @Column(updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;

    @OneToMany(mappedBy = "product", fetch = FetchType.LAZY)
    private Set<Review> reviews;

    @OneToMany(mappedBy = "product", fetch = FetchType.LAZY)
    private Set<RelatedProducts> relatedProducts;

//    @JsonIgnore
//    @OneToMany(mappedBy = "product")
//    private Set<CartItem> cartItems;

}
package com.genckart.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name="Related_Products")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class RelatedProducts {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer relatedId;

    @ManyToOne
    @JoinColumn(name="product_id", nullable=false)
    private Product product;

    @ManyToOne
    @JoinColumn(name="related_product_id", nullable=false)
    private Product relatedProducts;
}

package com.genckart.entity;
import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.*;
import java.sql.Timestamp;

@Entity
@Table(name="Reviews")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
public class Review {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer reviewId;

    @Column(name="user_id", nullable = false)
    private Integer userId;

    @ManyToOne
    @JoinColumn(name="product_id", nullable = false)
    @JsonBackReference
    private Product product;

    @Column(nullable = false)
    private int rating;

    private String reviewText;

    @Column(nullable = false, updatable = false, insertable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private Timestamp createdAt;
}

package com.genckart.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalException {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Product Not Found");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).substring(4));

        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<Object> handleMethodArgumentTypeMismatchException(MethodArgumentTypeMismatchException ex, WebRequest request) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        body.put("message", "Method parameter '" + ex.getName() + "': " + ex.getMessage());
        body.put("path", request.getDescription(false).substring(4));

        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<Object> handleRuntimeException(RuntimeException ex, WebRequest request) {
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).substring(4));

        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    // Add more exception handlers as needed
}
package com.genckart.exception;

public class ResourceNotFoundException extends RuntimeException{
    public ResourceNotFoundException() {
    }

    public ResourceNotFoundException(String categoryNotFound) {

    }
}

package com.genckart.repository;
import com.genckart.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

public interface CategoryRepository extends JpaRepository<Category, Integer> {
    Optional<Category> findByName(String name);
}

package com.genckart.repository;
import com.genckart.entity.Category;
import com.genckart.entity.Product;

import org.springframework.data.repository.query.Param;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
public interface ProductRepository extends JpaRepository<Product, Integer> {
    List<Product> findByNameContaining(String name);

    @Query("SELECT p FROM Product p WHERE p.category.categoryId = :categoryId AND p.productId <> :productId")
    List<Product> findRelatedProductsByCategory(@Param("categoryId") Integer categoryId, @Param("productId") Integer productId);

    List<Product> findByCategory(Category category);

    @Query("SELECT p FROM Product p LEFT JOIN FETCH p.reviews LEFT JOIN FETCH p.relatedProducts WHERE p.productId = :productId")
    Product findProductWithReviewsAndRelatedProducts(@Param("productId") Integer productId);

//    @Query("SELECT p FROM Product p WHERE p.name LIKE %:pattern% AND p.productId <> :productId")
//    List<Product> findRelatedProductsByPattern(@Param("pattern") String pattern, @Param("productId") Integer productId);
}

package com.genckart.repository;
import com.genckart.entity.Review;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ReviewRepository extends JpaRepository<Review, Integer> {
    List<Review> findByProductProductId(Integer productId);
    List<Review> findByUserId(Integer userId);
}
package com.genckart.service;

import com.genckart.dto.CategoryDTO;
import java.util.List;

public interface CategoryService {
    List<CategoryDTO> getAllCategories();
    CategoryDTO createCategory(CategoryDTO categoryDTO);
    CategoryDTO updateCategory(int id, CategoryDTO categoryDTO);
    void deleteCategory(int id);
    CategoryDTO getByCategoryId(int id);
    CategoryDTO getByCategoryName(String name);
}

package com.genckart.service;
import com.genckart.dto.CategoryDTO;
import com.genckart.entity.Category;
import com.genckart.repository.CategoryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CategoryServiceImpl implements CategoryService {

    @Autowired
    private CategoryRepository categoryRepository;

    @Override
    public List<CategoryDTO> getAllCategories() {
        return categoryRepository.findAll().stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Override
    public CategoryDTO createCategory(CategoryDTO categoryDTO) {
        Category category = convertToEntity(categoryDTO);
        category = categoryRepository.save(category);
        return convertToDTO(category);
    }

    @Override
    public CategoryDTO updateCategory(int id, CategoryDTO categoryDTO) {
        Category category = categoryRepository.findById(id).orElseThrow(() -> new RuntimeException("Category not found"));
        // Update category details
        category.setName(categoryDTO.getName());
        category.setParentId(categoryDTO.getParentId());
        category = categoryRepository.save(category);
        return convertToDTO(category);
    }

    @Override
    public void deleteCategory(int id) {
        categoryRepository.deleteById(id);
    }

    @Override
    public CategoryDTO getByCategoryId(int id) {
        Category category = categoryRepository.findById(id).orElseThrow(() -> new RuntimeException("Category not found"));
        return convertToDTO(category);
    }

    @Override
    public CategoryDTO getByCategoryName(String name) {
        Category category = categoryRepository.findByName(name).orElseThrow(() -> new RuntimeException("Category not found"));
        return convertToDTO(category);
    }

    private CategoryDTO convertToDTO(Category category) {
        CategoryDTO categoryDTO = new CategoryDTO();
        // Set fields from category to categoryDTO
        categoryDTO.setCategoryId(category.getCategoryId());
        categoryDTO.setName(category.getName());
        categoryDTO.setParentId(category.getParentId());
        return categoryDTO;
    }

    private Category convertToEntity(CategoryDTO categoryDTO) {
        Category category = new Category();
        // Set fields from categoryDTO to category
        category.setName(categoryDTO.getName());
        category.setParentId(categoryDTO.getParentId());
        return category;
    }
}

package com.genckart.service;

import com.genckart.dto.ProductDTO;
import java.util.List;

public interface ProductService {
    List<ProductDTO> getAllProducts();
    ProductDTO getProductById(Integer id);
    List<ProductDTO> getProductsByName(String name);
    ProductDTO addProduct(ProductDTO productDTO);
    ProductDTO updateProductDetails(Integer id, ProductDTO productDTO);
    void deleteProduct(Integer id);
    List<ProductDTO> getRelatedProducts(Integer productId);
    //    List<ProductDTO> getRelatedProductsByName(String name, Integer productId);
    List<ProductDTO> getRelatedProductsByCategoryName(String categoryName);
    ProductDTO getProductWithReviewsAndRelatedProducts(Integer productId);
}

package com.genckart.service;

import com.genckart.dto.ProductDTO;
import com.genckart.dto.ReviewDTO;
import com.genckart.entity.Category;
import com.genckart.entity.Product;
import com.genckart.exception.ResourceNotFoundException;
import com.genckart.repository.CategoryRepository;
import com.genckart.repository.ProductRepository;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ProductServiceImpl implements ProductService {

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private CategoryRepository categoryRepository;

    @Override
    public List<ProductDTO> getAllProducts() {
        return productRepository.findAll().stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Override
    public ProductDTO getProductById(Integer id) {
        Product product = productRepository.findById(id).orElseThrow(() -> new ResourceNotFoundException("Product not found"));
        return convertToDTO(product);
    }

    @Override
    public List<ProductDTO> getProductsByName(String name) {
        return productRepository.findByNameContaining(name).stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Override
    public ProductDTO addProduct(ProductDTO productDTO) {
        Product product = convertToEntity(productDTO);
        product = productRepository.save(product);
        return convertToDTO(product);
    }

    @Override
    public ProductDTO updateProductDetails(Integer id, ProductDTO productDTO) {
        Product product = productRepository.findById(id).orElseThrow(() -> new ResourceNotFoundException("Product not found"));
        // Update product details
        product.setName(productDTO.getName());
        product.setNewPrice(productDTO.getNewPrice());
        product.setOldPrice(productDTO.getOldPrice());
        product.setGender(productDTO.getGender());
        product.setQuantity(productDTO.getQuantity());
        product.setRating(productDTO.getRating());
        product.setBrand(productDTO.getBrand());
        product.setPopularity(productDTO.getPopularity());
        product.setColor(productDTO.getColor());
        product.setDescription(productDTO.getDescription());
        product.setImage1(productDTO.getImage1());
        product.setImage2(productDTO.getImage2());
        product.setImage3(productDTO.getImage3());
        product.setDiscount(productDTO.getDiscount());
        product.setHighlightShippingFee(productDTO.getHighlightShippingFee());

        Category category = categoryRepository.findByName(productDTO.getCategoryName())
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
        product.setCategory(category);

        product = productRepository.save(product);
        return convertToDTO(product);
    }

    @Override
    @Transactional
    public void deleteProduct(Integer id) {
        productRepository.deleteById(id);
    }

    @Override
    public List<ProductDTO> getRelatedProducts(Integer productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
        Integer categoryId = product.getCategory().getCategoryId();
        return productRepository.findRelatedProductsByCategory(categoryId, productId)
                .stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

//    @Override
//    public List<ProductDTO> getRelatedProductsByName(String name, Integer productId) {
//        Product product = productRepository.findById(productId)
//                .orElseThrow(() -> new ResourceNotFoundException("Product not found"));
//        String pattern = generatePattern(product.getName());
//        return productRepository.findRelatedProductsByPattern(pattern, productId)
//                .stream()
//                .map(this::convertToDTO)
//                .collect(Collectors.toList());
//    }

    private String generatePattern(String name) {
        // Generate a pattern to match more than 4 consecutive letters
        StringBuilder pattern = new StringBuilder();
        for (int i = 0; i <= name.length() - 4; i++) {
            pattern.append(name.substring(i, i + 4)).append("%");
        }
        return pattern.toString();
    }

    @Override
    public List<ProductDTO> getRelatedProductsByCategoryName(String categoryName) {
        Category category = categoryRepository.findByName(categoryName)
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
        return productRepository.findByCategory(category).stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Override
    public ProductDTO getProductWithReviewsAndRelatedProducts(Integer productId) {
        Product product = productRepository.findProductWithReviewsAndRelatedProducts(productId);
        return convertToDTOWithDetails(product);
    }

    private ProductDTO convertToDTO(Product product) {
        ProductDTO productDTO = new ProductDTO();
        // Set fields from product to productDTO
        productDTO.setProductId(product.getProductId());
        productDTO.setName(product.getName());
        productDTO.setNewPrice(product.getNewPrice());
        productDTO.setOldPrice(product.getOldPrice());
        productDTO.setGender(product.getGender());
        productDTO.setQuantity(product.getQuantity());
        productDTO.setRating(product.getRating());
        productDTO.setBrand(product.getBrand());
        productDTO.setPopularity(product.getPopularity());
        productDTO.setColor(product.getColor());
        productDTO.setDescription(product.getDescription());
        productDTO.setImage1(product.getImage1());
        productDTO.setImage2(product.getImage2());
        productDTO.setImage3(product.getImage3());
        productDTO.setDiscount(product.getDiscount());
        productDTO.setHighlightShippingFee(product.getHighlightShippingFee());
        productDTO.setCategoryName(product.getCategory().getName()); // Set category name
        return productDTO;
    }

    private ProductDTO convertToDTOWithDetails(Product product) {
        ProductDTO productDTO = convertToDTO(product);

        // Set reviews
        productDTO.setReviews(product.getReviews().stream().map(review -> {
            ReviewDTO reviewDTO = new ReviewDTO();
            reviewDTO.setReviewId(review.getReviewId());
            reviewDTO.setUserId(review.getUserId());
            reviewDTO.setRating(review.getRating());
            reviewDTO.setReviewText(review.getReviewText());
            reviewDTO.setCreatedAt(review.getCreatedAt());
            return reviewDTO;
        }).collect(Collectors.toList()));

        // Set related products
        productDTO.setRelatedProducts(product.getRelatedProducts().stream().map(relatedProduct -> {
            ProductDTO relatedProductDTO = new ProductDTO();
            relatedProductDTO.setProductId(relatedProduct.getRelatedProducts().getProductId());
            relatedProductDTO.setName(relatedProduct.getRelatedProducts().getName());
            relatedProductDTO.setNewPrice(relatedProduct.getRelatedProducts().getNewPrice());
            relatedProductDTO.setOldPrice(relatedProduct.getRelatedProducts().getOldPrice());
            relatedProductDTO.setGender(relatedProduct.getRelatedProducts().getGender());
            relatedProductDTO.setQuantity(relatedProduct.getRelatedProducts().getQuantity());
            relatedProductDTO.setRating(relatedProduct.getRelatedProducts().getRating());
            relatedProductDTO.setBrand(relatedProduct.getRelatedProducts().getBrand());
            relatedProductDTO.setPopularity(relatedProduct.getRelatedProducts().getPopularity());
            relatedProductDTO.setColor(relatedProduct.getRelatedProducts().getColor());
            relatedProductDTO.setDescription(relatedProduct.getRelatedProducts().getDescription());
            relatedProductDTO.setImage1(relatedProduct.getRelatedProducts().getImage1());
            relatedProductDTO.setImage2(relatedProduct.getRelatedProducts().getImage2());
            relatedProductDTO.setImage3(relatedProduct.getRelatedProducts().getImage3());
            relatedProductDTO.setDiscount(relatedProduct.getRelatedProducts().getDiscount());
            relatedProductDTO.setHighlightShippingFee(relatedProduct.getRelatedProducts().getHighlightShippingFee());
            relatedProductDTO.setCategoryName(relatedProduct.getRelatedProducts().getCategory().getName());
            return relatedProductDTO;
        }).collect(Collectors.toList()));

        return productDTO;
    }

    private Product convertToEntity(ProductDTO productDTO) {
        Product product = new Product();
        // Set fields from productDTO to product
        product.setName(productDTO.getName());
        product.setNewPrice(productDTO.getNewPrice());
        product.setOldPrice(productDTO.getOldPrice());
        product.setGender(productDTO.getGender());
        product.setQuantity(productDTO.getQuantity());
        product.setRating(productDTO.getRating());
        product.setBrand(productDTO.getBrand());
        product.setPopularity(productDTO.getPopularity());
        product.setColor(productDTO.getColor());
        product.setDescription(productDTO.getDescription());
        product.setImage1(productDTO.getImage1());
        product.setImage2(productDTO.getImage2());
        product.setImage3(productDTO.getImage3());
        product.setDiscount(productDTO.getDiscount());
        product.setHighlightShippingFee(productDTO.getHighlightShippingFee());

        Category category = categoryRepository.findByName(productDTO.getCategoryName())
                .orElseThrow(() -> new ResourceNotFoundException("Category not found"));
        product.setCategory(category);

        return product;
    }
}
package com.genckart.service;

import com.genckart.dto.ReviewDTO;
import java.util.List;

public interface ReviewService {
    List<ReviewDTO> getAllReviews();
    List<ReviewDTO> getReviewsByProductId(Integer productId);
    List<ReviewDTO> getReviewsByUserId(Integer userId);
    ReviewDTO createReview(ReviewDTO reviewDTO);
    void deleteReview(Integer reviewId);
}
package com.genckart.service;
import com.genckart.clients.UserClient;
import com.genckart.dto.ReviewDTO;
import com.genckart.dto.UserDTO;
import com.genckart.entity.Product;
import com.genckart.entity.Review;
import com.genckart.repository.ProductRepository;
import com.genckart.repository.ReviewRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ReviewServiceImpl implements ReviewService {

    @Autowired
    private ReviewRepository reviewRepository;

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private UserClient userClient;

    @Override
    public List<ReviewDTO> getAllReviews() {
        return reviewRepository.findAll().stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Override
    public List<ReviewDTO> getReviewsByProductId(Integer productId) {
        return reviewRepository.findByProductProductId(productId).stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Override
    public List<ReviewDTO> getReviewsByUserId(Integer userId) {
        return reviewRepository.findByUserId(userId).stream().map(this::convertToDTO).collect(Collectors.toList());
    }

    @Override
    public ReviewDTO createReview(ReviewDTO reviewDTO) {
        Review review = new Review();
        // Fetch user details from user profile management microservice
        ResponseEntity<UserDTO> responseEntity = userClient.getUserById(reviewDTO.getUserId());
        UserDTO userDTO = responseEntity.getBody();

        // Fetch product details
        Product product = productRepository.findById(reviewDTO.getProductId())
                .orElseThrow(() -> new RuntimeException("Product not found"));

        // Set fields from reviewDTO to review
        review.setRating(reviewDTO.getRating());
        review.setReviewText(reviewDTO.getReviewText());
        review.setUserId(userDTO.getUserId()); // Store userId instead of UserInfo object
        review.setProduct(product);

        review = reviewRepository.save(review);
        return convertToDTO(review, userDTO);
    }

    @Override
    public void deleteReview(Integer reviewId) {
        reviewRepository.deleteById(reviewId);
    }

    private ReviewDTO convertToDTO(Review review, UserDTO userDTO) {
        ReviewDTO reviewDTO = new ReviewDTO();
        // Set fields from review to reviewDTO
        reviewDTO.setReviewId(review.getReviewId());
        reviewDTO.setUserId(review.getUserId());
        reviewDTO.setProductId(review.getProduct().getProductId());
        reviewDTO.setRating(review.getRating());
        reviewDTO.setReviewText(review.getReviewText());
        reviewDTO.setUser(userDTO); // Include user details in the DTO
        return reviewDTO;
    }

    private ReviewDTO convertToDTO(Review review) {
        ReviewDTO reviewDTO = new ReviewDTO();
        // Set fields from review to reviewDTO
        reviewDTO.setReviewId(review.getReviewId());
        reviewDTO.setUserId(review.getUserId());
        reviewDTO.setProductId(review.getProduct().getProductId());
        reviewDTO.setRating(review.getRating());
        reviewDTO.setReviewText(review.getReviewText());
        return reviewDTO;
    }
}

package com.genckart;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableDiscoveryClient
public class ProductServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProductServiceApplication.class, args);
	}

}

user microservice:

package com.genckart.clients;

import com.genckart.dto.AddressDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

@FeignClient(name = "address-service")
public interface AddressClient {

    @PostMapping("/user/addresses")
    AddressDTO saveAddress(@RequestBody AddressDTO addressDTO);

    @PutMapping("/user/addresses/{id}")
    AddressDTO updateAddress(@PathVariable int id, @RequestBody AddressDTO addressDTO);

    @GetMapping("/user/addresses/{id}")
    AddressDTO getAddressById(@PathVariable int id);
}


package com.genckart.clients;

import com.genckart.dto.UserDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

@FeignClient(name = "user-service")
public interface UserClient {

    @PostMapping("/user/register")
    UserDTO registerUser(@RequestBody UserDTO userDTO);

    @PutMapping("/user/profile")
    UserDTO updateUser(@RequestBody UserDTO userDTO);

    @GetMapping("/user/profile/{id}")
    UserDTO getUserById(@PathVariable Integer id);
}


package com.genckart.clients;

import com.genckart.dto.UserPreferenceDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.*;

@FeignClient(name = "user-preference-service")
public interface UserPreferenceClient {

    @PostMapping("/user/preferences")
    UserPreferenceDTO saveUserPreference(@RequestBody UserPreferenceDTO userPreferenceDTO);

    @PutMapping("/user/preferences")
    UserPreferenceDTO updateUserPreference(@RequestBody UserPreferenceDTO userPreferenceDTO);
}

package com.genckart.controller;
import com.genckart.dto.AddressDTO;
import com.genckart.service.AddressService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/user/addresses")
public class AddressController {

    @Autowired
    private AddressService addressService;

    @PostMapping
    public ResponseEntity<AddressDTO> saveAddress(@RequestBody AddressDTO addressDTO) {
        AddressDTO savedAddress = addressService.saveAddress(addressDTO);
        return new ResponseEntity<>(savedAddress, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<AddressDTO> updateAddress(@PathVariable int id, @RequestBody AddressDTO addressDTO) {
        addressDTO.setAddressId(id);
        AddressDTO updatedAddress = addressService.updateAddress(addressDTO);
        return new ResponseEntity<>(updatedAddress, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<AddressDTO> getAddressById(@PathVariable int id) {
        AddressDTO address = addressService.getAddressById(id);
        return new ResponseEntity<>(address, HttpStatus.OK);
    }
}

package com.genckart.controller;
import com.genckart.dto.UserAuthDTO;
import com.genckart.dto.UserDTO;
import com.genckart.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping("/register")
    public ResponseEntity<UserDTO> registerUser(@Valid @RequestBody UserDTO userDTO) {
        UserDTO registeredUser = userService.registerUser(userDTO);
        return new ResponseEntity<>(registeredUser, HttpStatus.CREATED);
    }

    @PutMapping("/profile")
    public ResponseEntity<UserDTO> updateUser(@Valid @RequestBody UserDTO userDTO) {
        UserDTO updatedUser = userService.updateUser(userDTO);
        return new ResponseEntity<>(updatedUser, HttpStatus.OK);
    }

    @GetMapping("/profile/{id}")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Integer id) {
        UserDTO user = userService.getUserById(id);
        return new ResponseEntity<>(user, HttpStatus.OK);
    }

    @GetMapping("/profile/name/{name}")
    public ResponseEntity<UserAuthDTO> getUserByName(@PathVariable String name) {
        UserAuthDTO user = userService.getUserByName(name);
        return new ResponseEntity<>(user, HttpStatus.OK);
    }

    @GetMapping("/profile/email/{email}")
    public ResponseEntity<UserAuthDTO> getUserByEmail(@PathVariable String email) {
        UserAuthDTO user = userService.getUserByEmail(email);
        return new ResponseEntity<>(user, HttpStatus.OK);
    }
}

package com.genckart.controller;

import com.genckart.dto.UserPreferenceDTO;
import com.genckart.service.UserPreferenceService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/user/preferences")
public class UserPreferenceController {

    @Autowired
    private UserPreferenceService userPreferenceService;

    @PostMapping
    public ResponseEntity<UserPreferenceDTO> saveUserPreference(@RequestBody UserPreferenceDTO userPreferenceDTO) {
        UserPreferenceDTO savedPreference = userPreferenceService.saveUserPreference(userPreferenceDTO);
        return new ResponseEntity<>(savedPreference, HttpStatus.CREATED);
    }

    @PutMapping
    public ResponseEntity<UserPreferenceDTO> updateUserPreference(@RequestBody UserPreferenceDTO userPreferenceDTO) {
        UserPreferenceDTO updatedPreference = userPreferenceService.saveUserPreference(userPreferenceDTO);
        return new ResponseEntity<>(updatedPreference, HttpStatus.OK);
    }
}

package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class AddressDTO {
    private int addressId;
    private Integer userId;
    private String street;
    private String city;
    private String state;
    private String postalCode;
    private String country;
}
package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor

public class UserAuthDTO {
    private Integer userId;
    private String userName;
    private String email;
    private String role;
}


package com.genckart.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserDTO {

    private Integer userId;

    @NotBlank(message = "Name is mandatory")
    @Size(min = 2, max = 255, message = "Name must be between 2 and 255 characters")
    private String name;

    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is mandatory")
    private String email;

    @NotBlank(message = "Phone number is mandatory")
    @Pattern(regexp = "^\\+?[0-9. ()-]{7,25}$", message = "Phone number is invalid")
    private String phoneNumber;

    @JsonIgnore
    @NotBlank(message = "Password is mandatory")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    private String passwordHash;

    private String role;
}
package com.genckart.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserPreferenceDTO {
    private Integer preferenceId;
    private Integer userId;
    private Integer categoryId;
    private String brand;
    private Double minPrice;
    private Double maxPrice;
    private String gender;
}
package com.genckart.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.*;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "Address")
@ToString
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int addressId;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    @JsonBackReference
    private User user;

    @Column(nullable = false)
    private String street;

    @Column(nullable = false)
    private String city;

    @Column(nullable = false)
    private String state;

    @Column(nullable = false)
    private String postalCode;

    @Column(nullable = false)
    private String country;
}
package com.genckart.entity;
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer userId;

    @NotBlank(message = "Name is mandatory")
    @Size(min = 2, max = 255, message = "Name must be between 2 and 255 characters")
    private String name;

    @Email(message = "Email should be valid")
    @NotBlank(message = "Email is mandatory")
    @Column(unique = true, nullable = false)
    private String email;

    @NotBlank(message = "Phone number is mandatory")
    @Pattern(regexp = "^\\+?[0-9. ()-]{7,25}$", message = "Phone number is invalid")
    @Column(unique = true, nullable = false)
    private String phoneNumber;

    @NotBlank(message = "Password is mandatory")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    @Column(nullable = false)
    private String passwordHash;

    @Column(nullable = false)
    private String role;
}
package com.genckart.entity;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "user_preferences")
public class UserPreference {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer preferenceId;

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(name = "category_id")
    private Integer categoryId;

    @Column(name = "brand")
    private String brand;

    @Column(name = "min_price")
    private Double minPrice;

    @Column(name = "max_price")
    private Double maxPrice;

    @Column(name = "gender")
    private String gender;
}
package com.genckart.exception;

public class AddressNotFoundException extends RuntimeException{
    public AddressNotFoundException() {
    }

    public AddressNotFoundException(String message) {
        super(message);
    }
}
package com.genckart.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException() {
    }

    public UserNotFoundException(String message) {
        super(message);
    }
}
package com.genckart.repository;

import com.genckart.entity.Address;
import org.springframework.data.jpa.repository.JpaRepository;

public interface AddressRepository extends JpaRepository<Address, Integer> {
}
package com.genckart.repository;

import com.genckart.entity.UserPreference;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserPreferenceRepository extends JpaRepository<UserPreference, Integer> {
}
package com.genckart.repository;

import com.genckart.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Integer> {
    Optional<User> findByName(String name);
    Optional<User> findByEmail(String email);
}
package com.genckart.service;

import com.genckart.dto.AddressDTO;

public interface AddressService {
    AddressDTO saveAddress(AddressDTO addressDTO);
    AddressDTO updateAddress(AddressDTO addressDTO);
    AddressDTO getAddressById(int addressId);
}
package com.genckart.service;
import com.genckart.dto.AddressDTO;
import com.genckart.entity.Address;
import com.genckart.entity.User;
import com.genckart.exception.AddressNotFoundException;
import com.genckart.exception.UserNotFoundException;
import com.genckart.repository.AddressRepository;
import com.genckart.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AddressServiceImpl implements AddressService {

    @Autowired
    private AddressRepository addressRepository;

    @Autowired
    private UserRepository userRepository;

    @Override
    public AddressDTO saveAddress(AddressDTO addressDTO) {
        Address address = convertToEntity(addressDTO);
        Address savedAddress = addressRepository.save(address);
        return convertToDTO(savedAddress);
    }

    @Override
    public AddressDTO updateAddress(AddressDTO addressDTO) {
        Address address = convertToEntity(addressDTO);
        Address updatedAddress = addressRepository.save(address);
        return convertToDTO(updatedAddress);
    }

    @Override
    public AddressDTO getAddressById(int addressId) {
        Address address = addressRepository.findById(addressId).orElseThrow(() -> new AddressNotFoundException("Address not found"));
        return convertToDTO(address);
    }

    private Address convertToEntity(AddressDTO addressDTO) {
        Address address = new Address();
        address.setAddressId(addressDTO.getAddressId());
        address.setStreet(addressDTO.getStreet());
        address.setCity(addressDTO.getCity());
        address.setState(addressDTO.getState());
        address.setPostalCode(addressDTO.getPostalCode());
        address.setCountry(addressDTO.getCountry());

        // Set the user
        User user = userRepository.findById(addressDTO.getUserId())
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + addressDTO.getUserId()));
        address.setUser(user);

        return address;
    }

    private AddressDTO convertToDTO(Address address) {
        AddressDTO addressDTO = new AddressDTO();
        addressDTO.setAddressId(address.getAddressId());
        addressDTO.setStreet(address.getStreet());
        addressDTO.setCity(address.getCity());
        addressDTO.setState(address.getState());
        addressDTO.setPostalCode(address.getPostalCode());
        addressDTO.setCountry(address.getCountry());
        addressDTO.setUserId(address.getUser().getUserId());
        return addressDTO;
    }
}
package com.genckart.service;

import com.genckart.dto.UserPreferenceDTO;

public interface UserPreferenceService {
    UserPreferenceDTO saveUserPreference(UserPreferenceDTO userPreferenceDTO);
}
package com.genckart.service;

import com.genckart.dto.UserPreferenceDTO;
import com.genckart.entity.User;
import com.genckart.entity.UserPreference;
import com.genckart.exception.UserNotFoundException;
import com.genckart.repository.UserPreferenceRepository;
import com.genckart.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserPreferenceServiceImpl implements UserPreferenceService {

    @Autowired
    private UserPreferenceRepository userPreferenceRepository;

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserPreferenceDTO saveUserPreference(UserPreferenceDTO userPreferenceDTO) {
        UserPreference userPreference = convertToEntity(userPreferenceDTO);
        UserPreference savedUserPreference = userPreferenceRepository.save(userPreference);
        return convertToDTO(savedUserPreference);
    }

    private UserPreference convertToEntity(UserPreferenceDTO userPreferenceDTO) {
        UserPreference userPreference = new UserPreference();
        userPreference.setPreferenceId(userPreferenceDTO.getPreferenceId());
        userPreference.setCategoryId(userPreferenceDTO.getCategoryId());
        userPreference.setBrand(userPreferenceDTO.getBrand());
        userPreference.setMinPrice(userPreferenceDTO.getMinPrice());
        userPreference.setMaxPrice(userPreferenceDTO.getMaxPrice());
        userPreference.setGender(userPreferenceDTO.getGender());

        // Set the user
        User user = userRepository.findById(userPreferenceDTO.getUserId())
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + userPreferenceDTO.getUserId()));
        userPreference.setUser(user);

        return userPreference;
    }

    private UserPreferenceDTO convertToDTO(UserPreference userPreference) {
        UserPreferenceDTO userPreferenceDTO = new UserPreferenceDTO();
        userPreferenceDTO.setPreferenceId(userPreference.getPreferenceId());
        userPreferenceDTO.setCategoryId(userPreference.getCategoryId());
        userPreferenceDTO.setBrand(userPreference.getBrand());
        userPreferenceDTO.setMinPrice(userPreference.getMinPrice());
        userPreferenceDTO.setMaxPrice(userPreference.getMaxPrice());
        userPreferenceDTO.setGender(userPreference.getGender());
        userPreferenceDTO.setUserId(userPreference.getUser().getUserId());
        return userPreferenceDTO;
    }
}
package com.genckart.service;

import com.genckart.dto.UserAuthDTO;
import com.genckart.dto.UserDTO;

public interface UserService {
    UserDTO registerUser(UserDTO userDTO);
    UserDTO updateUser(UserDTO userDTO);
    UserDTO getUserById(Integer userId);
    UserAuthDTO getUserByName(String userName);
    UserAuthDTO getUserByEmail(String email);
}
package com.genckart.service;

import com.genckart.dto.UserAuthDTO;
import com.genckart.dto.UserDTO;
import com.genckart.entity.User;
import com.genckart.exception.UserNotFoundException;
import com.genckart.repository.UserRepository;
import com.genckart.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDTO registerUser(UserDTO userDTO) {
        User user = convertToEntity(userDTO);
        User savedUser = userRepository.save(user);
        return convertToDTO(savedUser);
    }

    @Override
    public UserDTO updateUser(UserDTO userDTO) {
        User existingUser = userRepository.findById(userDTO.getUserId())
                .orElseThrow(() -> new UserNotFoundException("User not found with ID: " + userDTO.getUserId()));

        existingUser.setName(userDTO.getName());
        existingUser.setEmail(userDTO.getEmail());
        existingUser.setPhoneNumber(userDTO.getPhoneNumber());
        existingUser.setPasswordHash(userDTO.getPasswordHash());
        existingUser.setRole(userDTO.getRole());

        User updatedUser = userRepository.save(existingUser);
        return convertToDTO(updatedUser);
    }

    @Override
    public UserDTO getUserById(Integer userId) {
        User user = userRepository.findById(userId).orElseThrow(() -> new UserNotFoundException("User not found"));
        return convertToDTO(user);
    }

    @Override
    public UserAuthDTO getUserByName(String userName) {
        User user = userRepository.findByName(userName).orElseThrow(() -> new UserNotFoundException("User not found with name: " + userName));
        return convertToAuthDTO(user);
    }

    @Override
    public UserAuthDTO getUserByEmail(String email) {
        User user = userRepository.findByEmail(email).orElseThrow(() -> new UserNotFoundException("User not found with email: " + email));
        return convertToAuthDTO(user);
    }

    private User convertToEntity(UserDTO userDTO) {
        User user = new User();
        user.setUserId(userDTO.getUserId());
        user.setName(userDTO.getName());
        user.setEmail(userDTO.getEmail());
        user.setPhoneNumber(userDTO.getPhoneNumber());
        user.setPasswordHash(userDTO.getPasswordHash());
        user.setRole(userDTO.getRole());
        return user;
    }

    private UserDTO convertToDTO(User user) {
        UserDTO userDTO = new UserDTO();
        userDTO.setUserId(user.getUserId());
        userDTO.setName(user.getName());
        userDTO.setEmail(user.getEmail());
        userDTO.setPhoneNumber(user.getPhoneNumber());
        userDTO.setPasswordHash(user.getPasswordHash());
        userDTO.setRole(user.getRole());
        return userDTO;
    }

    private UserAuthDTO convertToAuthDTO(User user) {
        UserAuthDTO userAuthDTO = new UserAuthDTO();
        userAuthDTO.setUserId(user.getUserId());
        userAuthDTO.setUserName(user.getName());
        userAuthDTO.setEmail(user.getEmail());
        userAuthDTO.setRole(user.getRole());
        return userAuthDTO;
    }
}

package com.genckart;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
@EnableDiscoveryClient
public class UserProfileManagementServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(UserProfileManagementServiceApplication.class, args);
	}

}





